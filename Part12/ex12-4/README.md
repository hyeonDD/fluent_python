<!-- 
[UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part12/ex12-1~2/UML_class_diagram.png)
 -->
# 다중 상속 다루기

---

상속에 대해서는 더 나은 이론이 필요했다 (사실 지금도 그렇다).
예를 들어 상속과 객체 생성(이것도 일종의 상속이다)은
어용론(공간을 절약하기 위한 코드 인수 분해 등)과
의미론(전문화, 일반화, 종분화 등 너무 많은 용도에 사용된다)을
모두 뒤섞어놓았다.</br>
**앨런 케이**

---

앨런 케이가 지적한 대로 상속은 다양한 목적으로 사용되며, 다중 상속은 대체 수단과 복잡도를 증가시킨다. 다중 상속은 이해하기 어렵고 불안정하게 설계하기 쉽다. 아직 종합적인 이론 체계를 갖추지는 못했지만, 다음의 조언에 따라 뒤엉킨 클래스 그래프가 만들어지는 것을 예방하자.

1. **인터페이스 상속과 구현 상속을 구분한다**
다음 상속을 다룰 때는 우선 상속 이유를 명확히 하는 것이 도움된다. 상속을 하는 이유는 주로 다음과 같다.
* 인터페이스 상속은 'is-a'관계를 의미하는 서브타입을 생성한다.
* 구현 상속은 재사용을 통해 코드 중복을 피한다.
실제로 이 두 가지 목적을 모두 가진 경우가 많지만, 의도를 명확히 할 수 있을 때는 명백히 표현하는 것이 좋다. 코드 재사용을 위한 상속은 구현에 관련된 것이며, 구성이나 위임으로 대체할 수 있는 경우도 종종 있다. 한편 인터페이스 상속은 프레임워크에서 중추적인 역할을 수행한다.

2. **ABC를 이용해서 인터페이스를 명확히 한다**
최신 파이썬에서는 인터페이스를 정의하기 위해 만들어진 클래스를 ABC로 명시한다. 파이썬 3.4 버전부터는 ABC로 명시하기 위해 abc.ABC나 다른 ABC를 상속하는 것을 의미한다(이전 버전의 파이썬을 지원하려면 11.7.1절'ABC 상세 구문'을 참조하라).

3. **코드를 재사용하기 위해 믹스인을 사용한다**
'is-a' 관계를 나타내지 않고 서로 관련 없는 여러 서브클래스에서 코드를 재사용하기 위해 설계된 클래스는 명시적으로 믹스인 클래스로 만들어야 한다. 개념적으로 믹스인 클래스는 새로운 자료형을 정의하지 않고, 단지 재사용할 메서드들을 묶어놓을 뿐이다. 믹스인 클래스로 객체를 생성하면 안 되며, 믹스인 클래스를 상속하는 구상 클래스는 다른 클래스도 상속해야 한다. 각각의 믹스인 클래스는 밀접히 연관된 메서드 몇 개를 구현해서 하나의 구체적인 행위를 제공해야 한다.

4. **이름을 통해 믹스인임을 명확히 한다**
파이썬에서는 믹스인 클래스를 명시하는 공식적인 방법이 없으므로, 클래스명 뒤에 Mixin을 붙일 것을 강력히 권장한다. Tkinter는 이런 권고를 따르지 않지만, 만약 이런 권고를 따랐다면 Xview 대신 XViewMixin, pack 대신 PackMixin 등 <<믹스인>>으로 표시된 클래스 모두 이름이 Mixin으로 끝났을 것이다.

5. **ABC가 믹스인이 될 수는 있지만, 믹스인이라고 해서 ABC인 것은 아니다**
ABC는 구상 메서드를 구현할 수 있으므로 믹스인으로 사용할 수도 있다. 그리고 ABC는 자료형을 정의하지만, 믹스인은 자료형을 정의하지 않는다. 게다가 ABC는 다른 클래스의 유일한 기저 클래스가 될 수 있는 반면, 믹스인 하나만 사용해서 서브클래스를 정의하면 안 된다(물론 특화된 믹스인을 정의하는 경우는 예외지만, 실제 코드에서 이런 구조를 보기 드물다).

6. **두개 이상의 구상 클래스에서 상속받지 않는다**
구상 클래스는 0개 또는 많아야 하나의 구상 슈퍼클래스를 가져야 한다. 즉, 구상 클래스의 슈퍼클래스 중 하나를 제외한 나머지 클래스는 ABC나 믹스인이어야 한다. 예를 들어 다음 코드에서 Alpha가 구상 클래스면, Beta와 Gamma는 ABC이거나 믹스인이어야 한다.
```
class MyConcreteClass(Alpha, Beta, Gamma):
    """구상 클래스: 객체를 생성할 수 있다."""
    # ... 클래스 코드 ...
```

7. **사용자에게 집합 클래스를 제공한다
ABC 또는 믹스인을 조합해서 호출 코드에 유용한 기능을 제공할 수 있을 때는, 이들을 적절히 통합하는 클래스를 제공하는 것이 좋다. 그래디 부치는 Object Oriented Analysis and Design, 3E(Addison-Wesley, 2007)에서 이런 클래스를 **집합 클래스**라고 불렀다.

예를 들어 tkinter.Widget의 전체 소스 코드는 다음과 같다.
```
class Widget(BaseWidget, Pack, Place, Grid):
    """내부 클래스.

    Pack, Place, Grid 기하 도형 관리자로 위치를 지정할 수 있는 위젯의
    기반 클래스""":
    pass
```
Widget 클래스의 본체가 비어 있지만, 클래스는 각종 서비스를 제공한다. Widget 클래스가 네개의 슈퍼클래스를 모아놓으므로, 위젯을 생성해야 하는 개발자는 이 믹스인을 모두 기억할 필요는 없으며, lass 문 안에서 특정 순서대로 선언해야 하는지 확인할 필요도 없다. 잠시 후 12.6절 '최신 사례: 장고 재너릭 뷰의 믹스인'에서 설명할 장고의 ListView는 집합 클래스의 좋은 사례를 보여준다.

8. **클래스 상속보다 객체 구성을 사용하라**
이 제목은 디자인 패턴에서 가져왔으며, 나로서는 이보다 훌륭하게 조언할 수 없을 것이다. 일단 상속에 익숙해지면 과도하게 사용하기 쉬워진다. 객체를 계층구조로 깔끔하게 정리하면 보기 좋아지며, 프로그래머는 이 일을 즐기게 된다.

그러나 구성을 더 좋아하게 되면 설계의 융통성이 향상된다. 예를 들어 tkinter.Widget 클래스의 경우 모든 기하 도형 관리자로부터 메서드를 상속하는 대신, 위젯 객체가 기하 도형 관리자를 참조하면서 메서드를 호출할 수도 있다. 어쨋든 위젯은 기하 도형 관리자가 되어서는 안 되지만, 위임을 통해 기하 도형 관리자의 서비스를 이용할 수 있다. 그런 후에는 위젯 클래스 게층 구조를 바꾸거나 구조를 바꾸거나 이름 충돌을 걱정할 필요 없이 새로운 기하 도형 관리자를 추가할 수 있다. 단일 상속의 경우에도 구성 방식은 융통성을 향상시킨다. 상속은 클래스드르을 강하게 결합시키며, 상속 트리의 높이가 높아지면 구조가 불안정해진다.

다른 클래스에 서비스를 제공하기 위해 사용할 때는 구성과 위임이 믹스인을 대체할 수 있지만, 자료형의 계층구조를 정의할 때는 구성과 위임이 인터페이스 상속을 대체할 수 없다.

이제 지금까지의 권고사항 관점에서 Tkinter를 분석해보자.

## Tkinter: 장점, 단점, 그리고 보기 흉함

---

Tkinter는 1994년 파이썬 1.1이 공개될 때부터 표준 라이브러리에 속했음을 명심하라. Tkinter는 Tcl 언어로 구현한 멋진 Tk GUI 툴킷 위에서 작동하는 계층이다. Tcl/Tk 조합이 원래 객체지향으로 설계된 것이 아니므로 Tk API는 기본적으로 아주 많은 함수로 구성되어 있다. 그러나 툴킷 구현은 함수로 되어 있더라도 개념적으로는 상당히 객체지향적이다.

---
Tkinter는 앞에서 권고한 사항 중 7번을 제외하고는 거의 모든 조언을 따르지 않는다. 8번 충고에서 설명한 것처럼 기하 도형 관리자를 위젯으로 통합하는 데는 구성을 이용하는 것이 더 좋으므로, 7번을 따르고 있다 하더라도 좋은 사례는 아니다.

tkinter.Widget의 문서화 문자열은 '내부 클래스'라는 단어로 시작한다. 이 설명에 따르면 Widget은 ABC여야 한다. Widget이 자체 메서드를 가조 있지 않지만, 실제로는 인터페이스를 정의하고 있다. 내부의 설명을 보면 'Tkinter 위젯은 __init__(), destroy() 등 수십 개의 Tk API 함수 및 세 개의 기하 도형 관리자가 제공하는 메서드를 외부에 제공한다'고 되어 있다. Widget은 그리 좋은 인터페이스 정의는 아니지만(그리고 너무 광범위하다), 인터페이스로서 자신의 슈퍼클래스들의 인터페이스의 합을 '정의'한다.

GUI 애플리케이션 논리를 구현하는 Tk 클래스는 Wm과 Misc를 상속하지만, 이 클래스 둘 다 추상 클래스도 아니고 믹스인도 아니다(TopLevel이 Wm만 상속하므로, Wm은 믹스인으로도 적절치 않다). Misc 클래스는 이름에서도 **코드 악취**가 난다. Misc는 100여 개의 메서드로 구성되어 있으며, 모든 위젯은 이 클래스를 상속한다. 모든 위젯이 클립보드 처리, 텍스트 선택, 타이머 관리 등의 기능을 모두 가지고 있어야 할 필요가 있을까? 복사한 것을 버튼에 붙여넣거나 스크롤바에서 텍스트를 선택할 수 없다. Misc를 여러개의 전문화된 믹스인 클래스로 분할하고 위젯은 각기 필요한 믹스인을 상속하는 것이 좋을 것이다.

덕분에 Tkinter 사용자는 다중 상속을 이해하거나 사용할 필요가 전혀 없다. 세부적인 구현 내용이 위젯 클래스 뒤에 감추어져 있으므로, 코드에서는 단지 객체를 생성하거나 상속하면 된다. 그러나 이렇게 과도한 다중 상속 때문에 dir(tkinter.Button) 코드를 실행해서 나온 214개의 속성 중에서 원하는 속성을 찾아내기 힘들 것이다.

이런 문제점에도 불구하고 Tkinter는 안정적이며, 융통성 있고, 그다지 보기 흉하지도 않다.
기본으로 사용하는 Tk 위젯은 과거의 유산으로서 최신 UI에는 어울리지 않지만, 2009년 파이썬 3.1부터 공개된 tkinter.ttk 패키지는 예쁘고, 네이티브 UI와 비슷한 느낌을 주므로 네이티브 애플리케이션과 비슷한 느낌의 애플리케이션을 개발할 수 있게 해준다. 게다가 Canvas와 Text 같은 레거시 위젯은 놀라울 정도로 강력하다. 약간만 코딩하면 Canvas 객체를 드래그앤드롭이 지원되는 그림 애플리케이션으로도 만들 수 있다. GUI 프로그래밍에 관심이 있다면 반드시 Tkinter와 Tcl/Tk를 살펴보기 바란다.

그러나 여기서의 주제는 GUI 프로그래밍이 아니라 다중 상속에 관해 공부하는 것이다. 장고에서는 명시적으로 믹스인 클래스를 사용하는 최신 사례를 볼 수 있다.