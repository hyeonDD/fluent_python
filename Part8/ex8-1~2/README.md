# 변수는 상자가아니다
<!-- 
![UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part8/ex8-1~2/UML_class_diagram.png)
 -->
1997년 MIT에서 자바 여름 강좌를 수강했다. 수상 경력이 빛나는 컴퓨터 과학 교육자이자 현재 프랭클린 W. 올린 공과대학교에서 강의하고 있는 린 안드레아 스타인 교수는 흔히 비유하는 '상자로서의 변수'개념이 실제로는 객체지향 언어에서 참조 변수를 이해하는 데 방해가 된다고 강조했다. 파이썬 변수는 자바에서의 참조 변수와 같으므로 변수는 객체에 붙은 레이블이라고 생각하는 것이 좋다.

아래 에제는 '상자로서의 변수'개념이 설명할 수 없는 간단한 코드다. 아래 그림을 보면 파이썬에서 상자 비유는 잘못된 반면, 포스트잇 변수가 실제 작동하는 방식을 잘 보여주고있다.
- [사본이 아니라 동일한 리스트를 참조하는 변수 a와 b](https://github.com/hyeonDD/fluent_python/blob/master/Part8/ex8-1~2/same_list.py)
![그림설명](https://github.com/hyeonDD/fluent_python/blob/master/Part8/ex8-1~2/그림.png)
스타인 교수는 할당에 대해서도 매우 신중하게 설명했다. 예를 들어 시뮬레이션에서 시소 객체에 대해 얘기할 때 '변수 s가 시소에 할당되었다'고 했지 '시소가 변수 s에 할당되었다'고 하지 않았다. 참조 변수의 경우 변수가 객체에 할당되었단는 표현이 객체를 변수에 할당했다는 표현보다 훨씬 타당하다. 결국 객체는 변수가 할당되기 전에 생성된다. 아래 예제는 할당문의 오른쪽이 먼저 실행된다는 것을 입증한다.

- [객체가 생성된 후에야 변수가 객체에 할당된다.](https://github.com/hyeonDD/fluent_python/blob/master/Part8/ex8-1~2/gizmo_class.py)
```
>>> x = Gizmo()
Gizmo id: 2517997942864 #1
>>> y = Gizmo() * 10    #2
Gizmo id: 2517997842384 #3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: unsupported operand type(s) for *: 'Gizmo' and 'int'
>>> dir()               #4
['Gizmo', '__annotations__', '__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__', 'x', 'y']
```
1. Gizmo id: ... 출력은 Gizmo 객체를 생성할 때 부수적으로 생성된다.
2. Gizmo 객체에 숫자를 곱하면 예외가 발생한다.
3. 곱셈을 시도하기 전에 두 번째 Gizmo 객체가 실제로 생성되었음을 입증한다.
4. 그러나 할당문의 오른쪽이 실행되는 동안 예외가 발생했기 때문에 변수 y는 결코 생성되지 않는다.

> 파이썬에서의 할당문을 이해하려면 언제나 오른쪽을 먼저 읽어야 한다. 할당문의 오른쪽에서 객체를 생성하거나 가져온다. 그 후 레이블을 붙이듯이 할당문 왼쪽에 있는 변수가 객체에 바인딩된다. 상자는 잊어버려라.

변수는 단지 레이블일 뿐이므로 객체에 여러 레이블을 붙이지 못할 이유가 없다. 여러 레이블을 붙이는 것을 **별명**이라고 하며, 다음절의 주제다.

# 정체성, 동질성, 별명

루이스 캐럴은 찰스 럿위지 도지슨 교수의 필명이다. 캐럴이 도지슨 교수와 같을 뿐만 아니라, 단 하나의 동일인이다. 아래 예제는 이 개념을 파이썬으로 표현한다.

- [동일한 객체를 참조하는 charles와 lewis](https://github.com/hyeonDD/fluent_python/blob/master/Part8/ex8-1~2/charles_lewis.py)
1. lewis는 charles의 별명이다.
2. is 연산자와 id() 함수로 이 사실을 확인한다.
3. lewis에 항목을 추가하는 것은 charles에 항목을 추가하는 것과 동일하다.

그런데 예를 들어 알렉산더 페다첸코 박사가 자신이 1832년에 태어난 찰스 L. 도지슨이라고 사칭하고 있다고 가정하자. 그의 자격 증명이 동일할 수는 있어도 페다첸코 박사가 도지슨 교수일 수는 없다.
![그림설명2](https://github.com/hyeonDD/fluent_python/blob/master/Part8/ex8-1~2/그림2.png)
- [위 그림2의 소스코드](https://github.com/hyeonDD/fluent_python/blob/master/Part8/ex8-1~2/charles_lewis_alex.py)
1. alex는 charles에 할단된 객체의 복제본을 가리킨다.
2. dict 클래스에서 __eq__()를 구현하는 방식 때문에 두 객체를 비교해서 같다고 판단한다.
3. 그러나 이 두 객체는 서로 별개의 객체다. a is not b로 기술하는 것은 두 객체의 정체성이 다르다고 표현하는 파이썬 방식이다.

위 예제는 **별명**의 예다. 코드 안에서 lewis와 charles는 별명이다. 두 변수가 동일 객체에 바인딩 되어있다. 한편 alex는 charles에 대한 별명이 아니다. 이 두변수는 서로 다른 객체에 바인딩되어 있다. alex에 바인딩된 객체와 charles에 바인딩된 객체가 동일한 **값**을 갖고 있으므로 == 연산자(동치 연산자)에 의해 동일하다고 판단되지만, 정체성은 다르다.

파이썬 언어 참조 문서의 3.1절 '객체,값,자료형'(http://bit.ly/1Vm9gv4)에서는 다음과 같이 설명하고 있다.
> 모든 객체는 정체성, 자료형, 값을 가지고 있다. 객체의 정체성은 일단 생성한 후에는 결코 변경되지 않는다. 정체성은 메모리 내의 객체 주소라고 생각할 수 있다. is 연산자는 두 객체의 정체성을 비교한다. id()함수는 정체성을 나타내는 정수를 반환한다.

객체 ID의 실제 의미는 구현에 따라 다르다. CPython의 경우 id()는 객체의 메모리 주소를 반환하지만, 다른 파이썬 인터프리터는 메모리 주소 이외의 다른 값을 반환할 수 도있다. 다만 ID는 객체마다 고유한 레이블이라는 것을 보장하며 객체가 소멸될 때까지 결코 변하지 않는다는 점이 핵심이다.

실제로 프로그래밍할 때는 id()함수를 거의 사용하지 않는다. 정체성 검사는 주로 is 연산자를 이용해서 수행하며 ID를 직접 비교하지는 않는다. 다음 절에서는 == 연산자와 is 연산자에 대해 설명한다.

## == 연산자와 is 연산자 간의 선택
== 연산자(동치 연산자)가 객체의 값을 비교하는 반면, is 연산자는 객체의 정체성을 비교한다.

정체성보다 값을 비교하는 경우가 많으므로, 파이썬 코드에서는 == 연산자를 is 연산자보다 자주 볼 수 있다.

그렇지만 변수를 싱글턴과 비교할 때는 is 연산자를 사용해야 한다. is 연산자를 사용할때는 변수를 None과 비교하는 경우가 일반적이다. 이 경우 다음과 같이 사용한다.

```
x is None
```
그리고 이 표현식의 반대는 다음과 같이 작성한다.
```
x is not None
```
is 연산자는 오버로딩할 수 없으므로 파이썬이 이 값을 평가하기 위해 특별 메서드를 호출할 필요가 없고, 두 정수를 비교하는 정도로 연산이 간단하므로 is 여낫나자가 == 연산자보다 빠르다. 반면 a == b는 a.__eq__(b)의 편리 구문이다. object 객체에서 상속받은 __eq__() 메서드는 객체의 ID를 비교하므로 is 연산자와 동일한 결과를 산출한다. 그러나 대부분의 내장 자료형은 __eq__() 메서드를 오버라이드해서 객체의 값을 비교한다. 대형 컬렉션이나 깊이 내포된 구조체를 비교하는 경우 동치 비교는 상당한 처리를 요구한다.

정체성과 동치성에 대한 설명을 마치기 전에, 불변성으로 유명한 튜플이 생각만큼 딱딱하지 않는다는 것을 확인해보자.

## 튜플의 상대적 불변성
리스트, 딕셔너리, 집합 등 대부분의 파이썬 컬렉션과 마찬가지로 튜플도 객체에 대한 참조를 담는다. 참조된 항목이 가변형이면 튜플 자체는 불변형이지만 참조된 항목은 변할 수 있다. 즉, 튜플의 불변셩은 tuple 데이터 구조체의 물리적인 내용(즉, 참조 자체)만을 말하는 것이며, 참조된 객체까지 불변성을 가지는 것은 아니다.

아래 예제는 튜플이 참조한 가변 객체의 변경에 의해 튜플의 값이 변경되는 상황을 설명한다. 튜플 안에서 결코 변경되지 않는 것은 튜플이 담고있는 항목들의 정체성뿐이다.

- [튜플의 값이 변경되는 경우](https://github.com/hyeonDD/fluent_python/blob/master/Part8/ex8-1~2/tuple_value_change.py)
1. t1은 불변형이지만, t1[-1]은 가변형이다.
2. t1과 항목이 같은 t2 튜플을 생성한다.
3. 서로 다른 객체지만, 예상한 대로 t1과 t2는 같다고 판단된다.
4. t1[-1]에 있는 리스트의 정체성을 확인한다.
5. t1[-1] 리스트를 그 자리에서 변경한다.
6. t1[-1]의 정체성은 그대로며 값만 변경되었다.
7. 이제 t1과 t2는 다르다고 판단된다.

이러한 튜플의 상대적 불변성 때문에 2.6.1절'[복합할당 퀴즈](https://github.com/hyeonDD/fluent_python/blob/master/Part2/ex2-5~8/compound_quiz.py)'같은 상황이 발생한다. 그리고 이는 3.1절의 '해시 가능하다는 말의 이미는?' 글상자에서 본 것처럼 일부 튜플이 해시 불가능한 이유이기도 하다.

동질성과 정체성 간의 차이는 객체를 복사할 때 더 큰 영향을 미친다. 사본은 ID가 다른 동일한 객체다. 그러나 객체가 다른 객체를 담고 있을 때 복사하면 내부 객체도 복사해야 할까? 아니면 내부 객체는 공유해도 될까? 정답은 없다.
