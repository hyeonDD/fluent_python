# 객체 참조, 가변성, 재활용

이 장에서 설명할 내용의 어조는 앨리스와 기사 간의 대화와 비슷하다. 주제는 객체와 그들의 이름 사이의 구분이다. 이름은 객체가 아니다. 이름은 별도의 것이다.

이 장에서는 먼저 파이썬 변수를 은유적으로 표현한다. 변수는 이름표지, 상자 자체가 아니다. 참조 변수를 이미 알고 있다면, 다른 사람에게 별명문제를 설명할 때 이 비유가 도움이 될것이다.

그러고 나서 객체의 정체성, 동질성, 별명의 개념을 이야기할 것이다. 튜플의 놀라운 성질도 드러난다. 튜플은 불변형이지만, 그 안에 들어 있는 값은 바뀔 수 있다. 그리고 얕은 복사와 깊은 복사에 대해 설명한다. 그 다음 주제는 참조 및 함수 매개변수다. 가변 매개변수가 기본이 될때의 문제 및 함수 호출자가 전달한 가변 인수의 안전한 처리에 대해 이야기한다.

이 장 마지막에서는 가비지 컬렉션과 del 명령 및 객체를 보존하지 않으면서 객체를 '기억'하기 위해 약한 참조를 사용하는 방법에 대해 설명한다.
이 장에서 설명하는 내용은 다소 무미건조하지만, 이 주제는 실제 파이썬 프로그램에서 발생하는 여러 미묘한 버그의 핵심 원인이기도 하다.

먼저 변수가 데이터를 저장하는 일종의 상자와 같다고 배웠던 것은 잊어버리자.

# 요약
모든 파이썬 객체는 정체성, 자료형, 값을 가지고 있다. 코드가 실행되는 동안 객체는 값만 바뀔 뿐이다.

변수 두 개가 동일한 값을 가진 불변 객체 (a == b가 참이다)를 가리키고 있다면, 변수가 각각의 사본을 가리키고 있는지 아니면 동일 객체에 대한 별명인지는 중요하지 않다. 어쨋든 불변 객체는 변하지 않기 때문이다. 단, 튜플이나 frozenset 등의 불변 컬렉션인 경우는 예외다. 불변 컬렉션이 가변 항목에 대한 참조를 담고 있는 경우, 가변 항목의 값이 바뀔 때 컬렉션의 값도 바뀐다. 사실 이런 상황이 흔한 것은 아니다. 불변 컬렉션에서 바뀌지 않는 것은 그 안에 들어 있는 객체의 정체성이며, 불변 컬렉션이 참조하는 가변 객체가 바뀌는 것을 막지 않는다.

변수가 참조를 담고 있다는 사실은 파이썬 프로그래밍에서 실제로 다음과 같은 영향을 미친다.

* 단순 할당문은 사본을 생성하지 않는다.
* +=나 *= 같은 복합 할당 연산자는 왼쪽 변수가 불변 객체에 바인딩되어 있을 때는 객체를 새로 생성하고, 가변 객체에 바인딩되어 있을 때는 기존 객체를 변경한다.
* 기존 변수에 새로운 값을 할당하면 기존에 바인딩되어 있던 객체를 변경하지 않는다. 이것ㅇㄹ 재바인딩이라고 하며, 변수가 새로운 객체에 바인딩되도록 만든다. 그 변수가 기존 객체를 참조하는 마지막 참조였다면, 기존 객체는 가비지 컬렉트된다.
* 함수 매개변수는 별명으로 전달되므로, 함수는 인수로 전달받은 가변 객체를 모두 변경할 수 있다. 가변 객체의 변경을 막으려면 함수 안에서 사본을 생성하거나, 리스트 대신 튜플을 전달하는 등 불변 객체를 사용해야 한다.
* 함수 매개변수의 기본값으로 가변 객체를 사용하는 것은 위험하다. 매개변수를 변경하면 기본값이 변경되어 이 기본값을 사용하는 함수가 나중에 호출될 때 영향을 받기 때문이다.

CPython에서 객체는 참조수가 0이 되는 순간 제거된다. 그리고 순환 참조 그룹을 형성해서 외부에서 참조할 수 없을 때도 제거된다. 때로는 객체의 참조수를 증가시키지 않으면서 객체를 참조해야 하는 경우가 있다. 자신의 객체를 모두 추적하려는 클래스의 경우가 이에 해당한다. 이때는 약한 참조를 사용한다. 약한 참조는 weakref 모듈의 WeakValueDictionary, WeakKeyDictionary, WeakSet 컬렉션 및 finalize() 함수의 기반이 되는 메커니즘이다.
