# del과 가비지 컬렉션
<!-- 
![UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part8/ex8-5/UML_class_diagram.png)
 -->
del 멸영은 이름을 제거하는 것이지, 객체를 제거하는 것이 아니다. del 명령의 결과로 객체가 가비지 컬렉트될 수 있지만, 제거된 변수가 객체를 참조하는 최후의 변수거나 객체에 도달할 수 없을 때만 가비지 컬렉트된다. 변수를 다시 바인딩해도 객체에 대한 참조 카운트를 0으로 만들어 객체가 제거될 수 있다.
> __del__()이라는 특별 메서드가 있기는 하지만, 객체가 제거되도록 만들지 않으며, 사용자 코드에서 직접 호출하면 안 된다. __del__()은 객체가 제거되기 직전에 외부 리소스를 해제할 기회를 주기위해 파이썬 인터프리터가 호출한다. 사용자 코드에서 __del__()을 구현해야 하는 경우는 거의 없지만, 종종 파이썬 초보자들이 타당한 이유 없이 이 메서드에 시간을 쏟는 경우가 있다. __del__()은 제대로 사용하기 다소 어렵다. 파이썬 언어 참조 문서의 '데이터 모델'장에서 __del__()특별 메서드 문서(http://bit.ly/IGsWPac)를 참조하라.

CPython의 경우 가비지 컬렉션은 주로 참조 카운트에 기반한다. 본질적으로 각 객체는 얼마나 많은 참조가 자신을 가리키는지 개수를 세고 있다. **refcount**가 0이 되자마자 CPython이 객체의 __del__() 메서드를 호출하고(정의되어 있는 경우) 객체에 할당되어있는 메모리를 해제함으로써 객체가 제거된다. CPython 2.0에는 순환 참조(그룹 안에서 서로 참조하고 있어서 참조 카운트는 0이 아니지만 도달할 수 없는 상태)에 관련된 객체 그룹을 탐지하기 위해 세대별 가비지 컬렉션 알고리즘을 추가했다. 다른 파이썬 구현에서는 참조 카운트에 기반하지 않는 더 정교한 가비지 컬렉터를 사용하므로, 객체제 대한 참조가 모두 사라진 경우에도 __del__() 메서드가 바로 호출되지 않을 수도 있다. __del__() 메서드의 적절한 사용과 부적절한 사용에 대해서는 제시 지류 데이비스의 'PyPy, 가비지 컬렉션, 데드락(http://bit.ly/1GsWTa7)을 참조하라.'
객체가 소멸될 때를 보여주기 위해 아래에서는 weakref.finalize()를 사용해서 객체가 소멸될 때 호출되는 콜백 함수를 등록한다.

```
가리키는 참조가 없을 때 객체가 소멸되는 것을 지켜보기
import weakref
s1 = {1,2,3}
s2 = s1
def bye():
    print('Gone with the wind...')

ender = weakref.finalize(s1, bye)
ender.alive
del s1
ender.alive
s2 = 'spam'
ender.alive
```
1. s1과 s2는 동일한 집합 {1, 2, 3}을 가르키는 별명이다.
2. 이 함수는 제거될 객체의 메서드에 바인딩되거나 제거될 객체를 참조하면 안 된다.
3. s1이 가리키는 객체에 대해 bye()콜백을 등록한다.
4. finalize 객체가 호출되기 전의 alive() 속성은 참이다.
5. 앞에서 설명한 대로 del은 객체가 아니라 객체에 대한 참조를 제거한다.
6. 마지막 참조인 s2를 다른 객체에 바인딩하면 {1, 2, 3} 튜플에 도달할 수 없게 된다. 튜플이 제거되고, bye()콜백이 호출되고, ender.alive는 거짓이 된다.

위 예제는 del이 객체를 제거하는것이 아니고, del을 실행한 후 객체가 도달할 수 없게 된 결과로 객체가 제거됨을 명확히 보여준다.

위에서 {1,2,3} 튜플 객체가 제거된 이유가 궁금할 것이다. 어쨋든 s1 참조가 finalize()함수에 전달되었고, finalize()함수는 객체를 감시하고 콜백을 호출하기 위해 객체에 대한 참조를 갖고 있는 것이 아닐까? 이 코드가 작동하는 것은 finalize()가 {1, 2, 3}튜플 객체에 대한 **약한 참조**를 가지고 있기 때문이다. 약한 참조에 대해서는 다음절에서 설명한다.

# 약한 참조
객체가 메모리에 유지되거나 유지되지 않도록 만드는 것은 참조의 존재 여부다. 객체 참조 카운트가 0이 되면 가비지 컬렉터는 해당 객체를 제거한다. 그러나 불필요하게 객체를 유지시키지 않으면서 객체를 참조할 수 있으면 도움이 되는 경우가 종종 있다. 캐시가 대표적인 경우다.

약한 참조는 참조 카운트를 증가시키지 않고 객체를 참조한다. 참조의 대상인 객체를 **참조 대상**이라고 한다. 따라서 약한 참조는 참조 대상이 가비지 컬렉트되는 것을 방지하지 않는다고 말할 수 있다.

약한 참조는 캐시 애플리케이션에서 유용하게 사용된다. 캐시가 참조하고 있다고 해서 캐시된 객체가 계속 남아 있기 원치 않기 때문이다.

아래 예제는 weakref.ref 객체를 호출해서 참조 대상에 접근하는 방법을 보여준다. 객체가 살아 있으면 약한 참조 호출은 참조된 객체를 반환하고, 그렇지 않으면 None을 반환한다.
> 아래 예제는 콘솔 세션이며, 파이썬 콘솔은 None이 아닌 표현식의 결과에 _ 변수를 자동으로 할당한다. 이런 성질 때문에 의도한 대로 예제를 보여줄 수는 없지만, 한편으로는 실제 상황을 잘 보여준다. 메모리를 섬세하게 제어하고자 할 때, 객체에 새로운 참조를 생성하는 암묵적인 할당 때문에 당황하는 경우가 종종 있다. _ 변수가 그런 사례다. Traceback 객체도 예기치 않은 참조를 만들어내는 원인이다.
```
약한 참조는 콜러블이다. 객체가 살아 있으면 참조된 객체를 반환하고, 그렇지 않으면 None을 반환한다.

import weakref
a_set = {0, 1}
wref = weakref.ref(a_set)
wref
wref()
a_set = {2,3,4}
wref()
wref() is None
wref() is None
```
1. 약한 참조 객체 wref를 생성하고 다음 행에서 조사한다.
2. wref()를 호출하면 참조된 객체 {0, 1}을 반환한다. 콘솔 세션에서 실행하고 있으므로 결과로 나온 {0,1}이 _ 변수에 바인딩된다.
3. a_set이 더 이상 {0, 1} 집합을 참조하지 않으므로 참조 카운트가 줄어든다. 그렇지만 _ 변수가 여전히{0, 1}을 참조한다.
4. wref()를 호출하면 여전히 {0, 1}이 반환된다.
5. 표현식을 평가할 때 {0, 1}이 살아 있으므로 wref()는 None이 아니다. 그렇지만 _ 변수는 결과값인 False에 바인딩된다. 이제 _ 변수는 더이상 {0, 1}을 참조하지 않는다.
6. 이제 {0, 1} 객체가 제거되었으므로 wref()를 호출하면 None이 반환된다.

weakref 모듈 문서(http://docs.python.org/3/library/weakref.html)에서는 weakref.ref 클래스는 고급 사용자를 위한 저수준 인터페이스며, 일반 프로그래머는 weakref 컬렉션과 finalize()를 사용하는 것이 좋다고 설명한다. 즉, weakref.ref 객체를 직접 만들기보다는 WeakKeyDictionary, WeakValueDictionary, WeakSet, 그리고 내부적으로 약한 참조를 이용하는 finalize()를 사용하는 것이 좋다. 위 예제에서는 weakref.ref 객체 하나가 작동하는 방식을 보면서 약한 참조 개념을 익히기 위해 weakref.ref 객체를 직접 만들었지만, 실제로 대부분의 파이썬 프로그램은 weakref 컬렉션을 사용한다.

다음 절에서는 weakref 컬렉션에 대해 살펴본다.

## WeakValueDictionary 촌극
WeakValueDictionary 클래스는 객체에 대한 약한 참조를 값으로 가지는 가변 매핑을 구현한다. 참조된 객체가 프로그램 다른 곳에서 가비지 컬렉트되면 해당 키도 WeakValueDictionary에서 자동으로 제거된다. 이 클래스는 일반적으로 캐시를 구현하기 위해 사용된다.

여기에서 설명하는 WeakValueDictionary 사용 예는 몬티 파이튼의 고전적인 '**치즈 가게**'촌극에서 영감을 받았다. '치즈 가게'촌극에서는 체다, 모차렐라 등 40여 종의 치즈를 고객이 주문하지만, 그중 어느 것도 재고가 없다.

아래 예제는 치즈의 종류를 나타내는 간단한 클래스를 구현한다.
```
kind 속성과 표준 표현 메서드를 가지고 있는 Cheese 클래스
class Cheese:

    def __init__(self, kind):
        self.kind = kind
    
    def __repr__(self):
        return 'Cheese(%r)' % self.kind
```

아래 예제는 치즈의 종류를 나타내는 간단한 클래스를 구현한다.
- [chess class](https://github.com/hyeonDD/fluent_python/blob/master/Part8/ex8-5/cheese.py)
1. stock은 WeakValueDictionary 객체다.
2. stock은 치즈명을 catalog에 있는 Cheese 객체에 대한 약한 참조로 매핑한다.
3. stock에 모든 치즈명이 들어 있다.
4. catalog를 제거한 후, 예상한 대로 WeakValueDictionary 객체인 stock에서 대부분의 치즈가 사라졌다. 그런데 하나가 남아 있는 이유는?
> 임시 변수가 객체를 참조함으로써 예상보다 객체의 수명이 늘어날 수 있다. 지역 변수는 함수가 반환되면서 사라지므로 일반적으로 문제가 되지 않는다. 그러나 위 예제의 경우 for 루프 변수인 cheese는 전역 변수이므로, 명시적으로 제거하기 전에는 사라지지 않는다.

WeakValueDictionary와 짝궁인 WeakKeyDictionary 클래스는 키가 약한 참조다. weakref.WeakKeyDictionary 문서(http://bit.ly/1GsXB6Z)의 다음과 같은 설명을 보면 이 클래스를 어디에 사용할지 감을 잡을 수 있다.
> **WeakKeyDictionary는 애플리케이션의 다른 부분에서 소유하고 있는 객체에 속성을 추가하지 않고 추가적인 데이터를 연결할 수 있다. 이 클래스는 속성 접근을 오버라이드하는 객체(디스크립터)에 특히 유용하다.**

weakref 모듈은 WeakSet 클래스도 제공한다(문서에는 WeakSet 클래스를 '요소를 약한 참조로 가리키는 집합 클래스. 어떤 요소에 대한 참조가 더 이상 존재하지 않으면 해당 요소가 제거된다'고 설명한다). 자신의 객체를 모두 알고 있는 클래스를 만들어야 한다면, 각 객체에 대한 참조를 모두 WeakSet 형의 클래스 속성에 저장하는 것이 좋다. 그렇게 하지 않고 일반 집합을 사용하면 이 클래스로 생성한 모든 객체는 가비지 컬렉트되지 않을 것이다. 클래스 자체가 객체에 대한 강한 참조를 하므로, 명시적으로 제거하지 않는 한 파이썬 프로세스가 종료될 때까지 객체가 제거되지 않기 때문이다.

지금까지 설명한 컬렉션과 약한 참조는 일반적으로 다룰 수 있는 객체의 종류가 한정되어 있다. 다음 절에서 자세히 알아보자.

## 약한 참조의 한계
모든 파이썬 객체가 약한 참조의 대상이 될 수 있는 것은 아니다. 기본적인 list와 dict 객체는 참조 대상이 될 수 없지만, 이 클래스들의 서브클래스는 이 문제를 다음 코드처럼 쉽게 해결할수 있다.

```
class Mylist(list):
    """약한 참조의 대상이 될 수 있는 list 서브클래스"""

a_list = Mylist(range(10))

# a_list는 약한 참조의 대상이 될 수 있다.
wref_to_a_list = weakref.ref(a_list)
```
set 객체는 참조 대상이 될 수 있다. 그렇기 때문에 위예제에서 set이 사용되었다. 사용자 정의형도 아무런 문제없이 참조 대상이 될 수 있다. 그래서 [chess class](https://github.com/hyeonDD/fluent_python/blob/master/Part8/ex8-5/cheese.py)에서 바보 같은 Cheese 클래스가 필요했던 것이다. 그러나 int 및 tuple 객체는 클래스를 상속해도 약한 참조의 대상이 될 수 없다.

이러한 제약사항 대부분은 CPython 구현 방식에 따른 것이므로, 다른 파이썬 구현에서는 적용되지 않을 수도 있다. 이들은 내부 구현 최적화에 의해 발생하는 문제며, 그중 일부에 대해 다음 절에서 설명한다.

 
