# 클래스 메타프로그래밍

클래스 메타프로그래밍은 실행 도중에 클래스를 생성하거나 커스터마이즈하는 기술을 말한다. 클래스는 파이썬의 일급 객체이므로, class라는 키워드를 사용하지 않고도 언제든 함수를 사용해서 생성할 수 있다. 클래스 데커레이터도 함수지만, 장식된 클래스를 조사하고, 변경하고, 심지어 다른 클래스로 대체할 수 있다. 끝으로, 메타클래스는 클래스 메타프로그래밍을 하기 위한 최첨단 도구로서, 우리가 이미 살펴본 추상 베이스 클래스처럼 특별한 기질이 있는 완전히 새로운 부류의 클래스를 만들 수 있게 해준다.

메타클래스는 강력하지만, 제대로 사용하기는 어렵다. 클래스 데커레이터는 이와 같은 문제의 상당 부분을 간단히 해결한다. 사실 메타클래스는 실제 코딩에서는 정당화하기 아주 어려우며, 파이썬 2.6에 클래스 데커레이터가 등장함으로써 필자가 즐겨 사용하던 흥미로운 예제들은 매력을 잃어버렸다.

그리고 여기서는 임포트 타음과 런타임을 구분한다. 파이썬에서 효율적으로 메타프로그래밍을 하기 위해서는 반드시 이 차이를 구분할 수 있어야 한다.
> 메타프로그래밍은 흥미로운 주제며, 휩쓸리기도쉽다. 그러므로 이 장은 다음과 같은 충고로 시작해야 할 것 같다. </br></br>프레임워크를 만들고 있지 않다면, 메타클래스를 작성해서는 안 된다. 그냥 재미로 하거나, 배운 개념을 적용해보기 위한 것이 아니라면.

먼저 런타임에 클래스를 어떻게 생성하는지 알아보자.

# 요약
클래스 메타프로그래밍은 클래스의 동적 생성 및 커스터마이즈에 관한 기법이다. 파이썬에서 클래스는 일급 객체이므로, type() 내장 메타클래스를 호출하는 함수를 이용해서 클래스를 생성하는 방법을 보여주면서 이 장을 시작했다.

그 다음 절에서는 20장에서 구현했던 디스크립터를 가진 LineItem 클래스로 돌아가서 관리 대상 속성명을 반영하는 저장소 속성명(즉,_Quantity#1 대신 _Quantity#price)을 생성하는 문제를 해결했다. 여기서는 클래스 데커레이터를 이용해서 해결했다. 클래스 데커레이터는 본질적으로 하나의 함수로서, 방금 생성한 클래스를 가져와서 조사하고, 변경하고, 심지어는 다른 클래스로 대체할 수도 있다.

그러고 나서 모듈의 소스 코드가 실제로 언제 실행되는지 설명했다. 소위 말하는 '임포트 타임'과 '런타임'이 약간 중복은 되지만, 상당히 많은 부분이 import문에 의해 실행된다. 언제 어느 코드가 실행되는지 이해하는 것은 정말 중요하며 약간 미묘한 규칙이 있으므로, 실제 연습문제를 이용해서 구체적으로 평가 시점을 확인해보았다.

그 다음에는 메타클래스에 대해 설명했다. 모든 클래스는 type 클래스의 직간접적인 객체며, type이 파이썬에서의 '루트 메타클래스'라는 것을 설명했다. 평가 시점 연습문제를 응용해서 메타클래스가 클래스 계층 구조 전체를 커스터마이즈할 수 있다는 것을 설명했다. 이는 클래스 하나에만 영향을 주며 서브클래스에는 영향을 주지 못하는 경우가 있는 클래스 데커레이터와 큰 차이점이다.

메타클래스를 처음에 실전에 응용해서 LineItem에서의 저장소 속성명 문제를 해결했다. 생성된 코드는 클래스 데커레이터보다 약간 더 어렵지만 별도의 모듈 안에 들어 있으므로, 사용자는 클래스 (model.Entity)가 커스터마이즈된 메나클래스(model.EntityMeta)의 객체인지 신경 쓸 필요 없이, 단지 클래스(model.Entity)를 상속하면 된다. 결국 이 코드는 자오과 SQLAlchemy의 ORM API와 비슷한 느낌이 든다. 이 API는 내부에 메타클래스를 사용하지만, 사용자는 이 점에 대해 전혀 알 필요가 없다.

두 번째 메나클래스 사례에는 model.EntityMeta에 약간의 기능을 추가했다. 즉, __prepare__() 메서드에서 OrderdDict를 제공해서 속성명을 속성에 매핑했다. 순서가 있는 딕셔너리를 사용해서 생성 중인 클래스 본체에 속성들이 바인딩되는 순서를 유지시켜주므로, __new__()와 __init__() 등의 메타클래스 메서드가 이 정보를 사용할 수 있게 해준다. 예제에서는 _field_names 클래스 속성을 이용해서 Entity.field_names()가 소스 코드에 나열한 순서대로 Validated 디스크립터를 가져올 수 있게 했다.

마지막 절에서는 파이썬의 모든 클래스에서 사용할 수 있는 속성과 메서드를 간략히 살펴봤다.

메타클래스는 어렵지만, 흥미롭고, 때로는 똑똑해 보이고 싶어 하는 프로그래머들이 남용하기도 한다. 이 장을 마치며, 11.4절의 '물새와 ABC'에서 알렉스 마르텔리가 했던 충고를 다시 한번 떠올려보자.
> 그리고 배포용 코드에서 절대로 ABC나 메타클래스를 직접 구현하지 '**말라**'.</br>ABC를 구현하고 싶은 생각이 든다면,</br>'멋진 망치로 새로 장만한 사람에게 모든 문제가 못으로 보이는'증세라고 확신할 수 있다.</br>깊이를 억제하고, 직관적이고 단순한 코드를 고수한 덕분에</br>나중에 여러분 코드를 유지모수할 사람이 훨씬 더 행복해질 것이다.</br>**-알렉스 마르텔리**

파이썬 메타프로그래밍의 대가일 뿐만 아니라 이 세상에서 가장 큰 핵심적인 파이썬 프로젝트에 참여하고 있는 성공한 소프트웨어 엔지니어의 덕담이다.