<!-- 
- [](https://github.com/hyeonDD/fluent_python/blob/master/Part21/ex21-3/aaa)
 -->
# 임포트 타임과 런타임
성공적으로 메타프로그래밍을 하려면, 파이썬 인터프리터가 언제 각 코드 블록을 평가하는지 알고 있어야 한다. 파이썬 프로그래머들은 '임포트 타임'과 '런타임'을 구분하지만, 이 용어들은 엄격히 정의되어 있지 않으며 구분이 모호한 경우도 있다. 임포트 타임에 인터프리터는.py 모듈에 들어 있는 소스 코드를 위에서부터 한 번 파싱하고, 실행할 바이트코드를 생성한다. 구문에러가 있으면 이때 발생한다. 만일 지역 __pycache__ 디렉터리에 최신 .pyc 파일이 있으면 바이트코드를 실행할 준비가 된 것이므로 이 과정을 생략한다.

컴파일 작업은 확실히 임포트 타임의 활동이긴 하지만, 이때 다른 일도 일어난다. 파이썬 대부분의 문장이 사용자 코드를 실행하고 사용자 프로그램의 상태를 변경한다는 의미에서 실행문이기 때문이다. import 문은 단지 단순한 선언이 아니며, 처음 임포트되는 모듈의 모든 최상위 수준 코드를 실제로 실행한다. 이후에 다시 임포트되는 경우에는 동일 모듈의 캐시를 사용하고 이름들만 바인딩한다. 최상위 수준 코드에는 데이터베이스에 연결하는 등 일반적으로 '런타임'에 수행하는 작업들도 포함될 수 있다. import 문이 각종 '런타임'의 동작을 유발하기 때문에 '임포트 타임'과 '런타임'의 구분이 모호해진다.

위 단락에서 임포트 타임에 '모든 최상위 수준 코드를 실행한다'고 말했지만, '최상위 수준 코드'에 대해 명확히 정의할 필요가 있다. 인터프리터는 모듈이 임포트될 때 모듈의 초상위 수준에서 def 문을 실행하지만, 그러면 어떤 일이 발생할까? 모듈이 처음 임포트될 때 인터프리터가 함수 본체를 컴파일하고 함수 객체를 전역 이름에 바인딩하지만, 함수 본체를 실행하는 것은 아니다. 일반적인 경우, 인터프리터는 최상위 수준 함수를 임포트 타임에 정의하지만, 런타임에 호출될 때만 실제로 함수를 실행한다.

클래스의 경우 이야기가 다르다. 인터프리터는 임포트 타임에 클래스 안에 들어 있는 클래스의 본체까지 모든 클래스 본체를 실행한다. 클래스 본체를 실행한다는 것은 클래스의 속성과 메서드가 정의되고, 클래스 객체가 만들어짐을 의미한다. 이런 관점에서 보면 클래스 본체는 '최상위 수준 코드'다. 임포트 타임에 실행되기 때문이다.

지금까지 다소 추상적으로 설명했으므로, 이제 예제 코드를 이용해서 언제 어떤 일이 발생하는지 구체적으로 알아보자.

## 코드 평가 시점 연습문제
evalsupport.py를 임포트하는 evaltime.py 스크립트가 있다고 가정하자. 이 모듈 둘 다 <[N]> 포맷으로 표시를 출력하는 print()문을 여러 개 가지고 있으며, 이때 N은 숫자다. 이 두 연습문제는 이 print() 문이 언제 호출되는지 알아보기 위한 것이다.
> 이 연습문제가 파이썬이 소스 코드를 어떻게 평가하는지 이해하는 데 많은 도움이 되었다고 학새들이 의견을 주었다. 794쪽 '시나리오 #1에 대한 해결책'을 보기 전에 직접 종이와 연필을 풀어보기 바란다.

evaltime.py 와 evalsupport.py는 각 모듈의 소스 코드다. 코드를 실행하지 말고, 종이와 연필을 들고 다음과 같은 두 가지 시나리오에서 숫자 표시가 나타날 순서를 적어보라.

---

**시나리오 #1**
파이썬 콘솔에서 evaltime.py 모듈을 임포트한다.
 >>> import evaltime

**시나리오 #2**
명령행에서 evaltime.py 모듈을 실행한다.
 $ python3 evaltime.py

---

### 시나리오 #1에 대한 해결책

아래 예제는 파이썬 콘솔에서 evaltime.py 모듈을 임포트한 결과다.
```
>>> import evaltime
<[100]> evalsupport module start #1
<[400]> MetaAleph body #2
<[700]> evalsupport module end  
<[1]> evaltime module start     
<[2]> ClassOne body #3
<[6]> ClassTwo body #4
<[7]> ClassThree body 
<[200]> deco_alpha #5
<[9]> ClassFour body
<[14]> evaltime module end #6
```
1. 모듈을 임포트할 때 evalsupport 모듈의 최상위 수준 코드가 실행된다. deco_alpha() 함수를 컴파일 하지만, 본체는 실행하지 않는다.
2. MetaAleph 클래스의 본체가 실행된다.
3. 모든 클래스의 본체가 실행된다.
4. 내포된 클래스도 실행된다.
5. 장식된 ClassThree의 본체가 평가된 후 데커레이터 함수가 실행된다.
6. 이 시나리오에서는 evaltime을 임포트했으므로 if __name__ == '__main__': 블록은 실행하지 않는다.

시나리오 #1에서 주의할 점은 다음과 같다.
1. 이 시나리오는 import evaltime 문으로 실행한다.
2. 인터프리터는 임포트된 모듈과 이 모듈이 임포트하는 모듈(evalsupport)에 들어 있는 모든 클래스를 실행한다.
3. 장식된 클래스에 붙어 있는 데커레이터 함수를 실행하기 전에 장식된 클래스의 본체를 먼저 평가한다. 데커레이터가 처리할 클래스 객체를 받아야 하므로, 클래스 객체를 먼저 생성하는 것이 당연하다.
4. 이 시나리오에서는 사용자 정의 함수나 메서드 중 deco_alpha() 데커레이터만 유일하게 실행된다.

이제 시나리오 #2에서는 어떻게 되는지 확인해보자.

### 시나리오 #2에 대한 해결책

아래예제는 python evaltime.py 명령으로 스크립트를 실행한 결과다.
```
$python evaltime.py
<[100]> evalsupport module start
<[400]> MetaAleph body
<[700]> evalsupport module end
<[1]> evaltime module start
<[2]> ClassOne body
<[6]> ClassTwo body
<[7]> ClassThree body
<[200]> deco_alpha
<[9]> ClassFour body #1
<[11]> ClassOne tests ..............................
<[3]> ClassOne.__init__ #2
<[5]> ClassOne.method_x
<[12]> ClassThree tests ..............................
<[300]> deco_alpha:inner_1 #3
<[13]> ClassFour tests ..............................
<[10]> ClassFour.method_y
<[14]> evaltime module end
<[4]> ClassOne.__del__ #4
```
1. 아직까지는 시나리오1과 동일하다.
2. 클래스의 표준 동작이다.
3. ClassThree.mthod_y가 deco_alpha() 데커레이터에 의해 변경되었으므로, three.method_y()를 호출하면 inner_1() 함수가 실행된다.
4. 전역 변수 one에 바인딩된 ClassOne 객체는 프로그램이 종료될 때가 되어서야 가비지 컬렉트된다.

시나리오 #2에서 핵심은 클래스 데커레이터가 변경한 내용이 서브클래스에 영향을 주지 않을 수 있다는 것이다. evaltime.py에서 ClassFour는 ClassThree의 서브클래스로 정의되어 있다. @deco_alpha 데커레이터는 ClassThree에 적용되어, 이 클래스의 method_y()를 대체했지만, ClassFour에는 전형 영향을 주지 않았다. 물론 ClassFour.method_y()에서 super()를 이용해서 ClassThree.method_y() 메서드를 실행했다면 데커레이터의 영향으로 inner_1() 함수를 실행했을 것이다.

다음 절에서는 클래스 데커레이터로 한 번에 한 클래스씩 변경하는 대신, 클래스 계층구조 전체를 커스터마이즈하고자 할 때는 메타클래스를 이용해서 더욱 효율적으로 처리할 수 있음을 보여준다.