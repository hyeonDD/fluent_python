# 시퀀스에 덧셈과 곱셈 연산자 사용하기

* 파이썬에서의 덧셈(+)과 곱셈(*)
    - 일반적으로 덧셈의 경우 피연산자 두 개가 같은 자료형이어야 하며, 둘다 변경되지 않지만 동일한 자료형의 시퀀스가 새로 만들어진다.
    - 덧셈 및 곱셈 연산자는 언제나 객체르 새로 만들고, 피연산자를 변경하지 않는다.

    - 리스트의 리스트를 만들땐 아래와 같이 지능형 리스트를 사용하는 것이 가장 좋다.

    [리스트 초기화 하기](https://github.com/hyeonDD/fluent_python/blob/master/Part2/ex2-5~8/init_list.py "소스코드")
    > a가 가변 항목을 담고 있을 때 a * n 과 같은 표현식을 사용하려면 주의해야 한다. 원치 않은 결과가 나올수 있기 때문이다. 예를 들어 리스트의 리스트를 초기화할 때 my_list = [[]] * 3으로 초기화하면 동일한 내부 리스트에 대한 참조 세 개를 가진 리스트가 만들어지므로, 원치 않는 결과가 나올 수 있다.


* 시퀀스 복합 할당
    - +=과 *= 등의 복합 할당 연산자는 첫 번째 피연산자에 따라 상당히 다르게 작동한다. += 연산자가 작동하도록 만드는 특수 메서드는 __iadd__()다 만약 이 메서드가 구현되어있지 않다면 __add__ 메서드를 호출한다.
 
    - 가변 시퀀스는 새로운 항목을 추가만 해주기에 타깃은 변하지 않지만, 불변 시퀀스는 새로운 항목을 추가하는 대신 항목이 추가된 시퀀스 전체를 새로 만들어 타깃 변수에 저장하므로 비효율적이다.

    [복합할당시퀀스](https://github.com/hyeonDD/fluent_python/blob/master/Part2/ex2-5~8/compound.py "소스코드")
    > str 은 불변 시퀀스지만 str객체에서만 작동방식이 다르다. 실제로 루프 안에서+= 연산자를 이용해서 문자열을 만드는 작업을 빈번히 수행하므로 CPython은 이런 용법에 최적화되어 있다. str 객체는 메모리 안에 여분의 공간을 갖고 할당되므로 str 객체를 연결할 때 매번 전체 문자열을 다시 생성하지 않는다.
    
    - 아래의 += 복합 할당 퀴즈를 보자
        [복합할당퀴즈](https://github.com/hyeonDD/fluent_python/blob/master/Part2/ex2-5~8/compound_quiz.py "소스코드")
        
        1. t는 (1,2,[30,40,50,60]) 이된다
        2. '튜플 객체는 항목 할당을 지원하지 않는다'는 메세지와 함께 TypeError가 발생한다.
        3. a와 b 둘 다 틀리다.
        4. a와 b 둘 다 맞다.

        - 위 퀴즈로부터 세가지를 알수있다.
            * 가변 항목을 튜플에 넣는 것은 좋은 생각이 아니다.
            * 복합 할당은 원자적인 연산이 아니다(앞의 예제에서 일부 연산이 수행된 후 예외가 발생했다.)
            * 파이썬 바이트코드를 살펴보는 것은 그리 어렵지 않으며, 내부에서 어떤 일이 발생하고 있는지 살펴보는 데 도움이 된다(import dis) 또는 [파이썬튜터](http://www.pythontutor.com/ "동작시각화사이트")

* 정렬된 시퀀스를 bisect로 관리하기
    - bisect 모듈은 bisect() 와 insort() 함수를 제공한다. bisect()는 이진 검색 알고리즘을 이용, insort() 는 정렬된 시퀀스 안에 항목을 삽입한다.

    [bisect예제](https://github.com/hyeonDD/fluent_python/blob/master/Part2/ex2-5~8/bisect_demo.py "소스코드")

    - 정렬은 값비싼 연산이므로 시퀀스를 정렬한 후에는 정렬 상태를 유지하는 것이 좋다. 이를 위한 함수가 insort()이다.

    [bisect.insort예제](https://github.com/hyeonDD/fluent_python/blob/master/Part2/ex2-5~8/bisect_insort.py "소스코드")

    

