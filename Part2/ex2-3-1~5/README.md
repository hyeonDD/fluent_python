# 튜플

- 튜플을 '불변 리스트'로만 설명하는 책이 있지만, 그러한 설명만으론 부족하다. 튜플은 불변리스트로도 사용할 수 있지만 필드명이 없는 레코드로도 사용할 수 있다.

* 레코드로서의 튜플
    - 튜플은 레코드를 담고 있다. 튜플의 각 항목은 레코드의 필드 하나를 의미하며 항목의 위치가 의미를 결정한다.

    [레코드로서의 튜플](https://github.com/hyeonDD/fluent_python/blob/master/Part2/ex2-3-1~5~5/tuple_as_record.py "소스코드")

    - 튜플은 언패킹 매커니즘 덕분에 레코드로도 잘 동작한다.

* 튜플 언패킹

    [레코드로서의 튜플](https://github.com/hyeonDD/fluent_python/blob/master/Part2/ex2-3-1~5~5/tuple_as_record.py "소스코드")
    - 위 소스코드를 보면 단 하나의 문장에서 city, year, pop, chg, are 변수에 여러 값을 할당했고, 마지막 행에서 print() 함수의 인수로 전달한 포맷 문자열의 각 슬롯에 passport 튜플의 각 항목을 할당했다.
    
    - 튜플 언패킹을 활용하면 임시 변수를 사용하지 않고도 두 변스의 값을 서로 교환할 수 있다. b, a = a, b 처럼

    - 인수앞에 *를 붙여 튜플을 언패킹 할수도 있다 (초과된 인수들을 전부가져옴).

    - _와 같은 더미 변수를 플레이스홀더로 사용해서 관심 없는 부분은 언패킹할 때 무시할 수 있다.

    - 언패킹할 표현식을 받는 튜플은 (a, b, (c, d))처럼 다른 튜플을 내포할 수 있으며, 파이썬은 표현식이 내포된 구조체에 일치하면 제대로 처리한다.
    [내표된 튜플 언패킹](https://github.com/hyeonDD/fluent_python/blob/master/Part2/ex2-3-1~5/tuple_as_record.py "소스코드")

* 명명된 튜플
    - 튜플은 아주 편리하다. 그러나 레코드로 사용하기에는 부족한점이 있다. 때로는 필드에 이름을 붙일 필요가 있기에 namedtuple() 함수가 고안되었다.

    - collections.namedtuple() 함수는 필드명과 클래스명을 추가한 튜플의 서브클래스를 생성하는 팩토리 함수로서, 디버깅할 때 유용하다.

    > 필드명이 클래스에 저장되므로 namedtuple()로 생성한 객체는 튜플과 동일한 크그의 메모리만 사용한다. 속성을 객체마다 존재하는 __dict__에 저장하지 않으므로 일반적인 객체보다 메모리를 적게 사용한다.

    [내표된 튜플 언패킹](https://github.com/hyeonDD/fluent_python/blob/master/Part1/ex2-3-1~5/ "defining_a_named_tuple.py")

    - 위 소스코드 에서 City를 정의한 방법을 보면 namedtuple은
        - 명명된 튜플을 정의하기 위해선 필드명의 리스트 등 총 2개의 매개변수가 필요하다.
        - 데이터는 위치를 맞추고 콤마로 구분해서 생성자에 전달해야한다.
        - 필드명이나 위치를 이용해서 필드에 접근할 수 있다.
    
    [내표된 튜플 언패킹](https://github.com/hyeonDD/fluent_python/blob/master/Part1/ex2-3-1~5/ "defining_a_named_tuple2.py")

    - 위 소스코드 에서 namedtuple은
        - _fields는 클래스의 필드명을 담고 있는 튜플이다.
        - _make()는 반복형 객체로부터 명명된 튜플을 만든다. City(*delhi_data)를 호출하는 코드와 동일한 역할을 수행한다.
        - _asdict()는 명명된 튜플 객체에서 만들어진 collections.OrderedDict 객체를 반환한다. 이 메서드를 이용하면 데이터를 멋지게 출력 할수 있다.


* 불변 리스트로서의 튜플
    - 튜플을 불변 리스트로 사용할때, 튜플과 리스트가 얼마나 비슷한지 알고있어야한다. 밑에 표를 보면 도움이 된다.

| 메서드 | 리스트  | 튜플 | 설명 |
| :--- | :--- | :--- | :--- |
| s.__add__(s2) | ● | ● | s + s2 -- 리스트를 연결한다.|
| s.__iadd__(s2) | ● || s += s2 -- 리스트를 연결하고 s에 저장한다.|
| s.append(e) | ● || 제일 뒤에 요소를 하나 추가한다.|
| s.clear() | ● || 모든 항목을 삭제한다.|
| s.__contains__(e) | ● | ● | e in s|
| s.copy() | ● || 리스트를 얕게 복사한다.|
| s.count(e) | ● | ● | e가 발생한 횟수를 계산한다.|
| s.__delitem__(p) | ● || p 위치의 요소를 삭제한다.|
| s.extend(it) | ● || 반복형 it 안에 있는 요소를 추가한다.|
| s.__getitem__(p) | ● | ● | s[p] -- p 위치의 요소를 가져온다.|
| s.__getnewargs__() || ● | pickle을 이용해서 최적화된 직렬화를 지원한다.|
| s.__index__(e) | ● | ● | s 안에서 e가 처음 나타나는 위치를 찾는다.|
| s.__insert__(p, e) | ● || p 위치에 있는 요소 앞에 e 요소를 삽입한다.|
| s.__iter__() | ● | ● | 반복자를 가져온다.|
| s.__len__() | ● | ● | len(s) -- 항목의 개수를 구한다.|
| s.__mul__(n) | ● | ● | s * n -- 문자열을 반복한다.|
| s.__imul__(n) | ● || s *= n -- 문자열을 반복하여 s에 저장한다.|
| s.__rmul__(n) | ● | ● | n * s -- 역순 반복 추가 메서드.|
|||||
| s.__pop__([p]) | ● || 마지막 항목이나 p 위치의 항목을 제거하고 반환한다.|
| s.__remove__(e) | ● || e 값을 가진 첫 번째 항목을 삭제한다.|
| s.__reverse__() | ● || 항목을 역순으로 배치한 후 s에 저장한다.|
| s.__reversed__() | ● || 마지막에서 첫 번째 항목까지 반복하는 반복자를 반환한다.|
| s.__setitem__(p, e) | ● || s[p] = e -- e를 p 위치에 저장하고, 기존 항목을 덮어쓴다.|
| s.sort([key], [reverse]) | ● || 선택적인 키워드 key와 reverser에 따라 항목을 정렬하고 s에 저장한다.|
