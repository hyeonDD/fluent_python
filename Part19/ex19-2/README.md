<!-- 
- [UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part19/ex19-2/UML_class_diagram.png)
 -->
# 속성을 검증하기 위해 프로퍼티 사용하기

지금까지는 읽기 전용 프로퍼티를 구현하기 위해 @property를 사용하는 예만 보았다. 이 절에서는 읽고 쓸 수 있는 프로퍼티를 만든다.

## LineItem 버전 #1: 주문 항목 클래스
유기농산물을 대량으로 판매하는 상점을 위한 앱을 생각해보자. 이 상점에서 고객은 땅콩, 견과류, 시리얼을 무게로 주문할 수 있다. 이 시스템에서 각각의 주문에는 일련의 품목명이 들어가며, 각 품목명은 아래 bulkfood_v1.py의 클래스로 표현된다.

- [bulkfood_v1.py](https://github.com/hyeonDD/fluent_python/blob/master/Part19/ex19-2/bulkfood_v1.py)

깔끔하고 간단하다. 너무 간단한 것이 아닌지 모르겠다. 그로므로 아래와 같은 문제가 발생할 수 있다.

```
raisins = LineItem('Golden rasisins', 10, 6.95)
raisins.subtotal()
# 69.5
raisins.weight = -20 # 쓰레기 값이 들어가니...
raisins.subtotal()   # 쓰레기 값이 나온다...
# -139.0
```

아주 간단한 예제지만, 생각만큼 멋지게 작동하지 않는다. 실제로 예전에 Amazon.com에서는 다음과 같은 일이 있었다고 한다.

> 고객기 책 수량을 음수로 주문할 수 있다는 사실을 알게 되었다!</br>
만일 그렇게 했다면 우리는 그 금액만큼을 고객의 크레디크 카드에 넣어주고,</br>
아마도 고객이 우리에게 책을 발송하기를 기다리고 있었을 것이다.</br>
**-제프 베조스</br>Amazon.com의 창업자 겸 CEO**

어떻게 고쳐야 할까? LineItem의 인터페이스를 변경해서 weight 속성에 게터와 세터를 사용할 수 있다. 이것은 자바의 방식이며, 잘못된 것은 아니다.

그러나 상품의 무게에 직접 값을 할당해서 설정하는 것이 자연스럽다. 그리고 이 시스템의 다른 부분에서 이미 item.weight 속성에 직접 접근하고 있을지도 모른다. 이럴 때는 데이터 속성을 플로퍼티로 변경하는 게 파이썬스러운 방식이다.

## LineItem 버전 #2 검증하는 프로퍼티
프로퍼티를 구현하면 게터와 세터 메서드를 사용할 수 있지만, LineItem의 인터페이스는 바뀌지 않는다(즉, 프로퍼티를 구현해도 LineItem의 weight 속성을 설정하기 위해 여전히 raisins.weight = 12와 같이 사용할 수 있다).

아래 예제는 bulkfood_v2.py의 읽기/쓰기 가능한 weight 프로퍼티 코드를 보여준다.

- [bulkfood_v2.py](https://github.com/hyeonDD/fluent_python/blob/master/Part19/ex19-2/bulkfood_v2.py)
1. 벌써 여기에서부터 프로퍼티 세터가 사용되어 음수 weight를 가진 객체가 생성되지 않게 한다.
2. @property로 게터 메서드를 장식한다.
3. 프로퍼티를 구현하는 메서드는 모두 공개 속성명(여기서는 weight)으로 되어 있다.
4. 실제로 값은 비공개 속성인 __weight에 저장된다.
5. 장식된 게터 메서드는 setter라는 속성을 가지고 있으며, 이것 또한 데커레이터다. 이렇게 해서 게터와 세터를 연결한다.
6. 값이 0보다 크면 비공개 속성인 __weight를 그 값으로 설정한다.
7. 그렇지 않으면 ValueError를 발생시킨다.

LineItem 객체를 생성할 때 무게를 잘못 입력하면 어떻게 되는지 살펴보자.

```
walnuts = LineItem('walnuts', 0, 10.00)
"""
Tracebak (most recent call last):
 ...
ValueError: value must be > 0
"""
```

이제 사용자가 잘못된 무게(weight)를 지정하지 못하도록 보호 장치를 마련했다. 그런에 일반적으로 구매자가 항목의 단가(price)를 설정할 수 없지만, 데이터 입력자의 실수로 인해 LineItem의 단가가 음수가 될 수도 있다. 이 문제를 방지하기 위해 price도 프로퍼티로 만들 수 있지만, 그러면 비슷한 코드를 반복하게 된다.

14장에서 폴 그레이엄이 '내 프로그램 안에 패턴이 보이면, 나는 이것을 문제의 징조라고 생각한다'고 한 말을 상기해보라. 반복을 치료하는 방법은 추상화다. 프로퍼티 정의를 추상화하려면 프로퍼티 팩토리나 디스크립터 클래스를 사용한다. 디스크립터 클래스는 융통성이 뛰어나며 20장에서 자세히 설명한다. 프로퍼티 자체도 사실은 디스크립터 클래스로 구현된다. 그렇지만 여기서는 프로퍼티 팩토리를 함수로 구현함으로써 프로퍼티 사용법을 계속 알아본다.

그러나 프로퍼티 팩토리를 구현하기 전에, 프로퍼티에 대해 좀 더 심도 있게 이해해야 한다.