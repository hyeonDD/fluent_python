# 일곱 가지 맛의 콜러블 객체

호출 연산자인 ()는 사용자 정의 함수 이외의 다른 객체에도 적용할 수 있다. 호출할 수 있는 객체인지 알아보려면 callable() 내장 함수를 사용한다.
파이썬 데이터 모델 문서는 다음 일곱 가지 콜러블을 나열하고 있다.

***
사용자 정의 함수
def 문이나 람다 표현식으로 생성한다.

내장 함수
len()이나 time.strftime()처럼 C 언어로 구현된 함수(CPython의 경우)

내장 메서드
dict.get()처럼 C 언어로 구현된 메서드

메서드
클래스 본체에 정의된 함수

클래스
호출될 때 클래스는 자신의 __new__() 메서드를 실행해서 객체를 생성하고, __init__()으로 초기화한 후, 최종적으로 호출자에 객체를 반환한다.
파이썬에는 new 연산자가 없으므로 클래스를 호출하는 것은 함수를 호출하는 것과 동일하다(일반적으로 클래스를 호출하면 해당 클래스의 객체가 생성되지만, __new__() 메서드를 오버라이딩하면 다르게 작동할 수도 있다. 19.1.3절 __new__()를 이용한 융통성 있는 객체 생성'에서 다르게 작동하는 예를 설명한다.)

클래스 객체
클래스가 __call__() 메서드를 구현하면 이 클래스의 객체는 함수로 호출될 수 있다.

제너레이터 함수
yield 키워드를 사용하는 함수나 메서드. 이 함수가 호출되면 제너레이터 객체를 반환한다.
***

제너레이터 함수는 여러모로 여타 콜러블과 다르다. 제너레이터에 대해서는 14장에서 자세히 다루며, 제너레이터 함수는 코루틴으로 사용될 수도 있는데, 코루틴은 16장에서 설명한다.
> 파이썬에는 다양한 콜러블형이 존재하므로, callable()내장 함수를 사용해서 호출할 수 있는 객체인지 판단하는 방법이 가장 안전하다.

```
abs,str,13
[callable(obj) for obj in (abs, str, 13)]
```

# 사용자 정의 콜러블형

파이썬 함수가 실제 객체일 뿐만 아니라, 모든 파이썬 객체가 함수처럼 동작하게 만들 수 있다.
단지 __call__() 인스턴스 메서드를 구현하면 된다.

- [뒤섞인 리스트에서 항목 골라내기](https://github.com/hyeonDD/fluent_python/blob/master/Part5/ex5-4~8/bingocall.py)
    위 예제는 반복 가능 객체를 받아서 그중 한 항목을 담은 객체를 생성하며, 무작위 순으로 내부에 항목들의 리스트를 저장한다. 객체를 호출하면 항목을 하나 꺼낸다.
    1. __init__()은 반복 가능 객체를 받는다. 지역에 사본을 만들면 인수로 전달된 리스트에 예기치 않은 부작용이 생기지 않도록 예방할 수 있다.
    2. self._items가 리스트이므로 shuffle()메서드가 실행되는 것을 보장할 수 있다.
    3. def pick()이 핵심 메서드
    4. self._items가 비어 있으면 사용자 정의 메세지를 담은 예외를 발생시킨다.
    5. bingo.pick()에 대한 단축 형태로 bingo()를 정의한다.

    BingoCage의 경우 객체를 함수처럼 호출할 때마다 항목을 하나 꺼낸 후 변경된 상태를 유지해야 하는데, __call__() 메서드를 구현하려면 이런 객체를 생성하기 쉽다. 이런 예로는 데커레이터가있다. 데커레이터는 함수지만, 때때로 호출된 후의 상태를 '기억'할 수 있는 기능이 유용하게 사용된다 (예를 들어 메모제이션의 경우, 값비싼 연산의 결과를 나중에 사용할 수 있도록 임시 보관해둔다.)
    클로저는 내부 상태를 가진 함수를 전혀 다른 방식으로 생성한다. 데커레이터와 마찬가지로 클로저는 7장에서 자세히 설명한다.

# 함수 인트로스펙션

함수 객체는 __doc__ 이외에도 많은 속성을 가지고 있다. dir()함수가 factorial()함수에 대해 공개하는 다음 내용을 살펴보자.

- [dir(factorial)](https://github.com/hyeonDD/fluent_python/blob/master/Part5/ex5-4~8/factorial.py)
    이 속성들 대부분은 일반적으로 파이썬 객체에 존재하는 속성이다. 이 절에서는 함수를 객체로 다루는 것과 관련된 속성들을 살펴본다.
    - 일반적인 사용자 정의 클래스의 객체와 마찬가지로 함수는 __dict__ 속성을 이용해서 객체에 할당된 사용자 속성을 보관한다. 이 속성은 기본적인 애너테이션 형태로서 쓸모가 많다. 일반적으로 어떤 속성을 함수에 할당하는 것은 흔한 일이 아니지만, 장고와 같은 프레임워크는 이 기능을 사용한다.[장고링크](https://docs.djangoproject.com/en/1.5/ref/contrib/admin)에 나오는 short_description, boolean, allow_tags 속성을 보자. 이 문서에서 다음 코드 예제는 어떤 메서드가 사용될 때 장고 관리자 화면에서 레코드 목록에 보여줄 설명 내용을 결정하기 위해 해당 메서드에 short_description 속성을 추가한다.
    
    ```
    def upper_case_name(obj):
        return ("%s %s" % (obj.first_name, obj.last_name)).upper()
    upper_case_name.short_description = 'Customer name'
    ```

이제 일반적인 파이썬 사용자 정의 객체에는 없지만 함수에 고유한 속성을 살펴보자. 두 집합의 차집합을 구하면 함수 고유의 속성을 간단히 볼 수 있다.

- [함수 고유의속성](https://github.com/hyeonDD/fluent_python/blob/master/Part5/ex5-4~8/func_unique.py)
    1. 기본적인 사용자 정의 클래스를 생성
    2. 그 클래스의 객체를 생성
    3. 기본적인 함수를 생성
    4. 뺄셈 연산을 이용해서 함수에는 존재하지만 기본 클래스의 객체에는 존재하지 않는 속성들을 정렬한 리스트를 만든다.

| 속성명 | 자료형  | 설명 |
| :--- | :--- | :--- |
| __annotations__ | dict | 매개변수 및 반환값에 대한 주석 |
| __call__ | 메서드-래퍼 | 콜러블 객체 프로토콜에 따른 ()연산자 구현. |
| __closuer__ | 튜플 | 자유 변수 등 함수 클로저(None인 경우가 종종 있다) |
| __code__ | 코드 | 바이트코드로 컴파일된 함수 메타데이터 및 함수 본체 |
| __defaults__ | 튜플 | 형식 매개변수의 기본값 |
| __get__ | 메서드-래퍼 | 읽기 전용 디스크립터 프로토콜 구현(20장 참조) |
| __globals__ | dict | 함수가 정의된 모듈의 전역 변수 |
| __kwdefaults__ | dict | 키워드 전용 형식 매개변수의 기본값 |
| __name__ | str | 함수명 |
| __qualname__ | str | random.choice()와 같은 전체 함수 명칭(PEP-3155(https://www.python.org./dev/peps/pep-3155)) |

함수 고유 속성의 대한 표이다, 파이썬이 함수 매개변수를 선언하고 인수를 전달하기 위해 사용하는 강력한 구문에 대해 알아보자.

# 위치 매개변수에서 키워드 전용 매개변수까지
<!-- 
[예](https://github.com/hyeonDD/fluent_python/blob/master/Part5/ex5-4~8/encode_decode.py)
 -->
 키워드 전용 인수를 이용해서 향상된, 파이썬 3의 지극히 융통성 있는 매개변수 처리 매커니즘은 파이썬 함수에서 볼 수 있는 가장 훌륭한 기능중 하나다.
 함수를 호출할때 반복 가능 객체나 매핑형을 별도의 인수로 '폭발'시키는 *와 **기호도 이 매커니즘과 밀접하게 연관되어 있다.
 이 기능이 어떻게 작동되는지 알아보기 위해 아래의 코드 및 사용을 보자.

- [HTML을 생성하는 tag()함수](https://github.com/hyeonDD/fluent_python/blob/master/Part5/ex5-4~8/tag_html.py)
    - 키워드 전용 인수는 파이썬 3에 새로 추가된 기능이다. 위 예제에서 cls 매개변수는 키워드 인수로만 전달될 수 있으며, 결코 익명의 위치인수로는 전달되지 않는다.
    - 함수를 정의할 때 키워드 전용 인수를 지정하려면 *가 붙은 인수 뒤에 이름을 지정한다. 가변 개수의 위치 인수를 지원하지 않으면서 키워드 전용 인수를 지원하고 싶으면,
    
    ```
    def f(a, *, b):
        return a,b
    f(1, b=2)
    ```
    위와 같이 *만 시그너처에 포함시키면 된다.
    - 키워드 전용 인수는 기본값을 지정하지 않아도 되며, 이전 예제의 b처럼 필수 인수로 만들 수 있다.

# 매개변수에 대한 정보 읽기

Bobo HTTP 프레임워크에서 함수 인트로스펙션을 적용한 재미있는 사례를 볼 수 있다. 아래 예제는 Bobo 튜토리얼 'Hello world'를 변형한 것으로서, 함수 인트로스펙션이 어떻게 작동하는지 알 수 있다.

- [Bobo HTTP](https://github.com/hyeonDD/fluent_python/blob/master/Part5/ex5-4~8/bobo.py)
    bobo.query() 데커레이터는 hello()와 같은 평범한 함수와 프레임워크에서 제공하는 요청처리 매커니즘을 결합시킨다.
    여기서 중요한 점은 Bobo가 hello()함수의 내부를 조사해서 이 함수가 작동하려면 person 이라는 매개변수가 필요하다는 것을 알아낸다는 것이다.
    그러고 나서 요청에서 해당 이름의 매개변수를 가져와서 hello()에 전달하므로 프로그래머는 요청 객체를 건드릴 필요가 전혀 없다.

    Bobo를 설치하고 개발 서버를 위 예제의 스크립트로 지정한 후(예를 들어 bobo -f hello.py), http://localhost:8080/ URL에 요청하면 403 HTTP 코드와 함께 'Missing form variable person'메세지가 나온다. hello를 호출하려면 person 인수가 필요한데, 그런 이름이 요청에 들어 있지 않다는 것을 Bobo가 알고 있기 때문이다.
    그러나 http://localhost:8080/?person=Jim 으로 요청한다면 Hello Jim!라는 문자열로 응답한다.

    함수에 어떤 매개변수가 필요한지, 매개변수에 기본값이 있는지 없는지 Bobo는 어떻게 알 수 있을까?

    함수 객체 안의 __defaults__ 속성에는 위치인수와 키워드 인수의 기본값을 가진 튜플이 들어 있다. 키워드 전용 인수의 기본값은 __kwdefaults__속성에 들어 있다.
    그러나 인수명은 __code__속성에 들어 있는데, 이 속성은 여러 속성을 담고 있는 code 객체를 가리킨다.

    이 속성들을 사용하는 방법을 알아보기위해 아래 예제를 살표보자.

- [__defaults__, __code__.co_varnames, __code__.co_argcount](https://github.com/hyeonDD/fluent_python/blob/master/Part5/ex5-4~8/clip_usage.py)
    정보가 그다지 사용하기 편하게 배치되어 있지 않다. 인수명이 __code__.co_varnames에 들어 있지만, 여기에는 함수 본체에서 생성한 지역 변수명도 들어 있다.
    따라서 앞에서 __code__.co_argcount개의 변수가 인수명이다. 이때 __CODE__.co_argcount에는 앞에 *나 **가 붙은 인수가 포함되어 있지 않다.
    인수의 기본값은 __defaults__튜플의 위치에 따라 알 수 있으므로, 인수를 뒤에서부터 추적하면서 각각의 기본값과 대응시켜야 한다. 위 예제에는 2개의 인수 text와 max_len이 있고
    기본값이 80 이므로, 이 기본값은 마지막 인수인 max_len에 해당한다. 처리과정이 보기 좋지 않다.

    다행히도 inspect 모듈을 사용하면 더 깔끔하게 처리할 수 있다.

- [inspect로 깔끔하게 보기](https://github.com/hyeonDD/fluent_python/blob/master/Part5/ex5-4~8/clip_inspect.py)
    이 결과가 훨씬 더 좋다. inspect.signature()는 insepct.Signature 객체를 반환하며, 이 객체에 들어 있는 parameters 속성을 이용하면 정렬된 inspect.Parameter 객체를 읽을 수 있다. 각 Parameter 객체 안에는 name, default, kind 등의 속성이 들어 있다. inspect._empy라는 특별한 값은 매개변수에 기본값이 없음을 나타낸다. None이 정당하면서도 널리 사용되는 기본값인 점을 고려하면 이런 특별한 값이 있는 게 당연하다.
    kind 속성은 _ParameterKind 클래스에 정의된 다섯 가지 값 중 하나를 가진다.

    ***
    POSITIONAL_OR_KEYWORD
    위치 인수나 키워드 인수로 전달할 수 있는 매개변수(파이썬 함수 매개변수 대부분이 여기에 속한다.)

    VAR_POSITIONAL
    위치 매개변수의 튜플

    VAR_KEYWORD
    키워드 매개변수의 딕셔너리

    KEYWORD_ONLY
    키워드 전용 매개변수(파이썬 3)

    POSITIONAL_ONLY
    위치 전용 매개벼수. 현재 파이썬 함수 선언 구문에서는 지원되지 않지만, 키워드로 전달한 매개변수를 받지 않는 dvimod()처럼 C 언어로 구현된 기존 함수가 여기에 속한다.
    ***
    name, default, kind 외에 inspect.Parameter 객체에는 annotation 속성이 있다.
    이 속성은 일반적으로 inspect._empty지만, 파이썬 3에서 제공하는 새로운 에너테이션 구문을 통해 제공된 함수 시그너처 메타데이터가 들어갈 수 있다(에너테이션에 대해서는 다음 절에서 설명한다).

    inspect.Signature 객체에는 bind() 메서드가 정의되어 있다. bind() 메서드는 임의 개수의 인수를 받고, 인수를 매개변수에 대응시키는 일반적인 규칙을 적용해서 그것을 시그너처에 들어 있는 매개변수에 바인딩한다. bind() 메서드는 프레임워크에서 실제 함수를 호출하기 전에 인수를 검증하기 위해 사용할 수 있다.

