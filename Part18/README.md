# asyncio를 이용한 동시성

이므리 사이먼 교수는 동일한 것을 의미하기 위해 다른 단어를 사용하는 것과 동일한 단어를 이용해서 여러 가지를 의미하는 것은 과학에서의 2대 죄악이라고 이야기하곤 했다. 동시성이나 병렬 프로그래밍에 대해 연구하다보면 '동시성'과 '병렬성'에 대한 상이한 정의를 발견할 수 있다. 필자는 앞에서 인용한 롭 파이크의 비공식 정의를 따른다.

진짜 병렬로 처리하려면 CPU 코어가 여러 개 있어야 한다. 최신 랩톱 컴퓨터는 4개의 CPU 코어를 가지고 있지만, 일반적인 운용 환경에서도 100개 이상의 프로세스를 일상적으로 실행한다. 따라서 실제로는 대부분의 처리가 동시에 수행되지만 병렬로 수행되지는 않는다. 컴퓨터는 한 번에 고작해야 4개의 작업을 병렬로 처리할 수 있지만, 100개 이상의 프로세스를 계속 처리하면서 각 프로세스가 진행할 수 있게 보장한다. 10년 전에 필자는 코어가 하나밖에 없지만 100개의 프로세스를 처리할 수 있는 컴퓨터를 사용했다. 그렇기 때문에 롭 파이크가 자신의 발표자료 제목을 '동시성은 병럴처리가 아니다(더 낫다)'라고 한 것이다.

이 장에서는 이벤트 루프에 의해 운용되는 코루틴을 이용해서 동시성을 구현하는 asyncio 패키지에 대해 설명한다. 이 패키지는 파이썬에 추가된 가장 거대하고 야심찬 라이브러리 중 하나다. 귀도 반 로섬은 asyncio를 파이썬 리포지토리(저장소) 외부에서 개발하고, 프로젝트 코드명을 '튤립'이라고 했다. 그래서 인터넷에서 이 주제에 대해 검색할 때 tulip이라는 이름을 많이 볼 수 있다. 예를 들어 주요 토론 그룹명은 아직도 python-tulip (http://bit.ly/1HGtMiO) 이다.

파이썬 3.4의 표준 라이브러리에 추가되면서 튤립이라는 이름이 asyncio로 변경되었다. asyncio는 파이썬 3.3과도 호환되며, PyPI에서 새로운 공식명 (https://pypi.python.org/pypi/asyncio) 으로도 볼 수 있다. yield from 표현식을 아주 ㅁ낳이 사용하므로, asyncio는 이전 버전의 파이썬과는 호환되지 않는다.
> 튤립처럼 꽃 이름을 딴 Trollius 프로젝트 (http://tollius.readthedocs.org) 는 asyncio를 파이썬 2.6이후 버전으로 하위 포팅한 것으로서, yield from을 'yield'와 'From과 Return이라는 이름을 가진 콜러블'로 대체한다. yield from...에서 yield From(...) 형태로 바뀌고, 결과를 반환해야 하는 코루틴은 return result에서 raise Return(result)로 바뀌었다. Trollius 프로젝트는 asyncio의 핵심 개발자인 빅터 스티너에 의해 주도되었으며, 친절하게도 빅터는 이 책을 제작하고 있는 동안 이 장 내용을 검토해주었다.

이 장에서는 당므과 같은 내용을 설명한다.
* 간단한 스레드 프로그램과 그에 준하는 asyncio 버전을 비교하면서, 스레드와 비동기 작업의 관계를 보여준다.
* asyncio.Future 클래스와 concurrent.futures.Future 클래스의 차이점을 설명한다.
* 17장에서 구현한 국기 내려받기 예제의 비동기 버전을 구현한다.
* 스레드나 프로세스를 사용하지 않고 비동기 프로그램ㅇ이 네트워크 프로그램에서 높은 동시성을 관리하는 방법을 설명한다.
* 코루틴으로 비동기 프로그래밍을 하기 위한 콜백을 개선시키는 방법을 설명한다.
* 블로킹 연산을 스레드 풀에 덜어줌으로써 이벤트 루프를 블로킹하지 않는 방법을 알아본다.
* asyncio 서버를 작성하고, 웹 애플리케이션의 높은 동시성을 다시 생각해본다.
* asyncio가 파이썬 생태계에서 커다란 영향을 줄 수 밖에 없는 이유를 설명한다.

먼저 threading과 asyncio를 비교해볼 수 있는 간단한 예제를 만들어보자.

# 요약
이 장에서는 yield from, 코루틴, Future 객체, asyncio 이벤트 루프를 활용해서 파이썬에서 동시성을 구현하는 전혀 새로운 방법을 설명했다. 처음 나온 간단한 텍스트 스피너 에제는 동시성에 대한 threading 모듈과 asyncio 모듈을 나랗니 비교하기 위해 만든 것이었다.

그러고 나서 yield from의 지원 및 코루틴과 asyncio.Task와의 관계를 위주로 asyncio.Future의 특징을 구체적으로 살펴보았다. 다음으로 asyncio를 기반으로 한 국기 내려받는 스크립트를 분석했다.

그리고 입출력 지연과 블로킹 함수의 영향에 대한 라이언 달의 사이클 수를 살펴봤다. 어쩔 수 없이 블로킹 함수를 사용하면서도 프로그램을 살아 움직이게 만들려면 스레드와 비동기 호출, 두 가지 방법을 사용할 수 있다. 비동기 호출은 콜백이나 코루틴으로 구현한다.

실제로 비동기 라이브러리는 커널 수준까지 내려가는 저수준 스레드에 의존하지만, 라이브러리 사용자는 스레드를 생성하거나 내부적으로 스레드가 사용되고 있다는 사실을 알 필요 없다. 애플리케이션 수준에서는 단지 우리가 작성한 코드가 블로킹되지 않게 보장하면 되며, 이벤트 루프가 동시성에 대한 나머지 모든 작업을 처리해준다. 비동기식 시스템은 사용자가 스레드를 관리할 필요성을 제거함으로써 멀티스레드 시스템보다 더 많은 동시성 연결을 관리할 수 있다.

그리고 다시 국기 내려받기 예제로 돌아와, 진행 막대와 에러 처리를 추가함으로써 코드를 상당히 많이 리팩토링했다. 특히 asyncio.wait()에서 asyncio.as_completed()로 전환하면서 download_many()의 기능 대부분을 새로 만든 downloader_coro() 코루틴으로 옮겨야 했다. 그럼으로써 yield from을 이용해서 asyncio.as_completed()에 의해 생성된 Future 객체로 부터 하나하나 결과를 가져올 수 있었다.

그러고 나서 loop.run_in_executor() 메서드를 이용해서 파일 저장과 같은 블로킹 작업을 스레드 풀에 위임하는 방법을 살펴보았다.

이어서 콜백이 가진 심각한 문제를 코루틴이 해결하는 방법에 대해 논의했다. 콜백을 사용하는 경우 다단계 비동기식 작업을 수행할 때 콘텍스트가 손실되므로 에러를 처리하기 위한 콘텍스트가 부족하다는 문제가 있다. 그 다음 예제에서는 국기 이미지와 함께 국가명을 가져오는 코드를 구현하면서, 코루틴과 yield from 조합을 이용해서 소위 말하는 콜백 지옥을 피하는 방법을 설명했다. yield from 키워드를 무시하면서 보면, yield from을 이용해서 비동기식 함수를 다단계로 호출하는 코드가 단지 일반적인 순차 코드처럼 보일 정도다.

이 장 마지막 예제에서는 문자명으로 유니코드 문자를 검색할 수 있게 해주는 asyncio TCP 서버와 HTTP 서버를 구현했다. HTTP 서버 분석을 마친 후, 커다란 HTML 페이지를 내려받는 대신 필요에 따라 클라이언트가 조금씩 요청할 수 있게 해주는 사례를 보면서 서버 측의 동시성을 높이기 위한 클라이언트 측 코드의 중요성에 대해 이야기했다.