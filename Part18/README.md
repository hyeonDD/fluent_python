# asyncio를 이용한 동시성

이므리 사이먼 교수는 동일한 것을 의미하기 위해 다른 단어를 사용하는 것과 동일한 단어를 이용해서 여러 가지를 의미하는 것은 과학에서의 2대 죄악이라고 이야기하곤 했다. 동시성이나 병렬 프로그래밍에 대해 연구하다보면 '동시성'과 '병렬성'에 대한 상이한 정의를 발견할 수 있다. 필자는 앞에서 인용한 롭 파이크의 비공식 정의를 따른다.

진짜 병렬로 처리하려면 CPU 코어가 여러 개 있어야 한다. 최신 랩톱 컴퓨터는 4개의 CPU 코어를 가지고 있지만, 일반적인 운용 환경에서도 100개 이상의 프로세스를 일상적으로 실행한다. 따라서 실제로는 대부분의 처리가 동시에 수행되지만 병렬로 수행되지는 않는다. 컴퓨터는 한 번에 고작해야 4개의 작업을 병렬로 처리할 수 있지만, 100개 이상의 프로세스를 계속 처리하면서 각 프로세스가 진행할 수 있게 보장한다. 10년 전에 필자는 코어가 하나밖에 없지만 100개의 프로세스를 처리할 수 있는 컴퓨터를 사용했다. 그렇기 때문에 롭 파이크가 자신의 발표자료 제목을 '동시성은 병럴처리가 아니다(더 낫다)'라고 한 것이다.

이 장에서는 이벤트 루프에 의해 운용되는 코루틴을 이용해서 동시성을 구현하는 asyncio 패키지에 대해 설명한다. 이 패키지는 파이썬에 추가된 가장 거대하고 야심찬 라이브러리 중 하나다. 귀도 반 로섬은 asyncio를 파이썬 리포지토리(저장소) 외부에서 개발하고, 프로젝트 코드명을 '튤립'이라고 했다. 그래서 인터넷에서 이 주제에 대해 검색할 때 tulip이라는 이름을 많이 볼 수 있다. 예를 들어 주요 토론 그룹명은 아직도 python-tulip (http://bit.ly/1HGtMiO) 이다.

파이썬 3.4의 표준 라이브러리에 추가되면서 튤립이라는 이름이 asyncio로 변경되었다. asyncio는 파이썬 3.3과도 호환되며, PyPI에서 새로운 공식명 (https://pypi.python.org/pypi/asyncio) 으로도 볼 수 있다. yield from 표현식을 아주 ㅁ낳이 사용하므로, asyncio는 이전 버전의 파이썬과는 호환되지 않는다.
> 튤립처럼 꽃 이름을 딴 Trollius 프로젝트 (http://tollius.readthedocs.org) 는 asyncio를 파이썬 2.6이후 버전으로 하위 포팅한 것으로서, yield from을 'yield'와 'From과 Return이라는 이름을 가진 콜러블'로 대체한다. yield from...에서 yield From(...) 형태로 바뀌고, 결과를 반환해야 하는 코루틴은 return result에서 raise Return(result)로 바뀌었다. Trollius 프로젝트는 asyncio의 핵심 개발자인 빅터 스티너에 의해 주도되었으며, 친절하게도 빅터는 이 책을 제작하고 있는 동안 이 장 내용을 검토해주었다.

이 장에서는 당므과 같은 내용을 설명한다.
* 간단한 스레드 프로그램과 그에 준하는 asyncio 버전을 비교하면서, 스레드와 비동기 작업의 관계를 보여준다.
* asyncio.Future 클래스와 concurrent.futures.Future 클래스의 차이점을 설명한다.
* 17장에서 구현한 국기 내려받기 예제의 비동기 버전을 구현한다.
* 스레드나 프로세스를 사용하지 않고 비동기 프로그램ㅇ이 네트워크 프로그램에서 높은 동시성을 관리하는 방법을 설명한다.
* 코루틴으로 비동기 프로그래밍을 하기 위한 콜백을 개선시키는 방법을 설명한다.
* 블로킹 연산을 스레드 풀에 덜어줌으로써 이벤트 루프를 블로킹하지 않는 방법을 알아본다.
* asyncio 서버를 작성하고, 웹 애플리케이션의 높은 동시성을 다시 생각해본다.
* asyncio가 파이썬 생태계에서 커다란 영향을 줄 수 밖에 없는 이유를 설명한다.

먼저 threading과 asyncio를 비교해볼 수 있는 간단한 예제를 만들어보자.