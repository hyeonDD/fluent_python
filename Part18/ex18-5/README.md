<!-- 
- [UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part18/ex18-5/UML_class_diagram.png)
 -->
# 콜백에서 Future와 코루틴으로

코루틴을 이용해서 이벤트 주도 프로그램을 작성하는 데 익숙해지려면 어느 정도 공부를 해야한다. 그러므로 코루틴이 어떻게 고전적인 콜백 스타일을 향상시키는지 명확히 알아두는 것이 좋다. 이것이 바로 이 절에서 설명할 내용이다.

콜백 스타일의 이벤트 주도 프로그래밍을 해본 경험이 있다면 '콜백 지옥'이라는 용어를 잘 알것이다. 콜백 지옥은 어떤 연산이 다른 연산에 종속적일 때 콜백 안에 콜백이 들어가는 것을 말한다. 차례대로 발생해야 하는 비동기 호출이 세 개 있을 때는 아래 예제의 자바스크립트 코드에서 보는 것처럼 세 단계의 콜백을 구현해야 한다.

```
# 자바스크립트에서의 콜백 지옥: 내포된 익명 함수, 즉 파멸의 피라미드(Pyramid of Doom) (http://survivejs.com/common_problems/pyramid.html)
api_call1(request1, function (response1) {
    // 1단계
    var request2 = step1(response1);

    api_call2(request2, function (response2) {
        // 2단계
        var request3 = set2(response2);

        api_call3(request3, function (response3) {
            // 3단계
            setp3(response3);
        });
    });
});
```
위 자바스크립트 예제에서 api_call1(), api_call2(), api_call3()는 결과를 비동기식으로 가져오기 위해 사용하는 라이브러리 함수로서, 예를 들어 api_call1()은 데이터베이스 연결, api_call2()는 웹 서비스에서 데이터를 가져오는 연산 등으로 생각하면 된다. 각 라이브러리 함수는 콜백 함수를 받으며, 자바스크립트에서는 익명 함수(다음 예제에서 stage1, stage1, stage3로 명명되었다)를 사용할 수 있다. 여기서 1단계, 2단계, 3단계라는 주석이 달려 있는 부분은 콜백이 받은 응답을 처리하는 일반적인 함수를 나타낸다.

아래 예제는 이와 같은 콜벡 지옥을 파이썬에서 구현한 모습을 보여준다.
```
# 파이썬에서의 콜백 지옥: 콜백 사슬

def stage1(response1):
    request2 = setp1(response1)
    api_call2(request2, stage2)

def stage2(response2):
    request3 = step2(response2)
    api_call3(request3, stage3)

def stage3(response3):
    step3(response3)

api_call1(request1, stage1)
```

위 예제의 함수 배치는 자바스크립트의 예제와 상당히 다르지만, 하는 일은 똑같다. 자바스크립트 예제를 파이썬 에제와 같이 구성할 수 있지만, 파이썬 예제는 람다의 구문 제한 때문에 자바스크립트처럼 작성할 수 없다.

자바스크립트의 예제나 위 예제처럼 구성된 코드는 작성하기도 어렵지만, 읽기도 어렵다. 각 함수의 작업의 일부를 수행하고, 다음 콜백을 설정하고 반환해서 이벤트 루프가 계속 수행할 수 있게 한다. 이때 모든 지역 콘텍스트가 사라진다. 예를 들어 stage2() 함수가 실행될 때 request2의 값은 더 이상 존재하지 않는다. 이 값이 필요하면 클로저나 외부 데이터 구조체에 값을 저장해서 다른 단계의 작업에서 사용할 수 있게 해야 한다.

이런 상황에서는 코루틴이 정말 도움이 된다. 세 개의 비동기 작업을 연속으로 처리하기 위해 코루틴 체인에서 yield를 세 번 사용해서 이벤트 루프가 계속 실행할 수 있게 해주면 된다. 결과가 나오면 코루틴의 send() 메서드를 호출해서 코루틴을 활성화하면 된다. 이벤트 루프의 관점에서 보면 send() 메서드를 호출해서 코루틴을 활성화하면 된다. 이벤트 루프의 관점에서 보면 send() 메서드 호출과 콜백 메서드 호출은 비슷하다. 그러나 코루틴 스타일의 비동기 API를 사용하는 입장에서 보면 상황이 훨씬 좋아진다. 하나의 함수 안에서 전체 작업의 콘텍스트를 지역 변수 안에 넣고, 일반적인 함수를 호출하듯이 연속으로 세 개의 함수를 호출하면 되기 때문이다. 아래예제를 보자.

```
# 코루틴과 yield from을 사용하면 콜백 없이 비동기식으로 프로그래밍할 수 있다.
@asyncio.coroutine
def three_stages(request1):
    response1 = yield from api_call1(request1)
    # 1단계
    request2 = step1(response1)
    response2 = yield from api_call2(request2)
    # 2단계
    request3 = step2(response2)
    response3 = yield from api_call3(request3)
    # 3단계
    step3(resposne3)

loop.crate_task(three_stages(request1)) #명시적으로 실행을 스케줄링해야 한다.
```
위 예제는 앞에서 본 자바스크립트와 파이썬 예제보다 이해하기 훨씬 더 쉽다. 세 단계의 연산이 하나의 함수 안에 나란히 나타난다. 이렇게 구현하면 다음 단계에서 앞 단계의 결과를 사용하기 쉽다. 게다가 예외를 통해 에러를 보고하기 위한 콘텍스트(지역 변수 등)도 제공한다.

예를 들어 파이썬예제에서 api_call2(request2, stage2)를 처리하다가 입출력 예외가 발생했다고 하자(1단계의 마지막 줄을 수행하는 중이다). api_call2()가 비동기식 함수이므로 1단계에서 예외를 잡을 수 없고, 모든 입출력 연산을 수행하기 전에 즉시 반환한다. 콜백 기반의 API에서는 각각의 비동기 함수를 호출할 때, 연산에 성공한 경우를 처리하는 콜백과 연산에 실패한 경우를 처리하는 콜백 등 총 2개의 콜백을 등록해서 처리한다. 에러를 처리하게 되면 콜백지옥 상황이 급격히 악화된다.

이와 반대로, 바로 위 에제에서는 3단계 연산을 하나의 함수(예제에서는 three_stages() 함수) 안에서 나란히 비동기식으로 호출하므로, 각각의 yield from을 각기 별도의 try/except 블록 안에 넣어서 api_call1(), api_call2(), api_call3()가 발생시키는 예외를 처리할 수 있다.

이것이 콜백 지옥보다는 훨씬 낫지만, 그렇다고 해서 코루틴 천국이라고 할 수도 없다. 어느 정도 대가를 치러야 하기 때문이다. 일반 함수 대신 반드시 코루틴을 사용해야 하고 yield from에 익숙해져야 하므로, 이것이 첫 번째 장애물이다. 일단 함수 안에서 yield from을 사용하면 이 함수는 코루틴이 되므로, 파이썬으로 짜여진 에제에서 콜백 체인을 시작하기 위해 호출했던 api_call1(request1, stage1) 처럼 평범하게 호출할 수 없다. 이벤트 루프를 이용해서 코루틴 실행을 명시적으로 스케줄링하거나, 실행을 위해 스케줄링된 다른 코루틴 안에서 yield from을 이용해서 활성화해야 한다. 바로 위예제의 마미작 행에서 loop.create_task(three_stages(request1))을 호출하지 않으면 아무것도 실행되지 않는다.

이제 지금까지 배운 이론을 활용해보자.

## 한 번 내려받을 때 여러 가지 요청하기

단순히 국가 코드만 사용하는 대신 국가 코드와 국가명을 사용해서 각 나라의 국기를 저장하는 경우를 생각해보자. 이제는 국기 이미지뿐만 아니라 국가명이 들어 있는 metadata.json 파일도 동일 디렉터리에서 가져와야 하므로, 이미지 하나마다 HTTP 요청을 두 번 해야 한다. 스레드 버전에서는 동일 작업 안에서 여러 요청을 명시하기 쉽다. 단지 한 번 요청한 후에 다음번 요청을 하면서 스레드를 두 번 블로킹하고, 두 가지 데이터(국기 코드와 국가명)를 지역 변수에 저장해서 파일을 저장할 때 사용하면 된다. 그런테 콜백을 이용한 비동기 스크립트로 이와 동일한 작업을 구현하려 하면 콜백 지옥의 악취가 나기 시작한다. 국가 코드와 국가명을 클로저에 전달하거나 어딘가에 보관해서 파일을 저장할 때까지 가지고 있어야 한다. 각각의 콜백이 서로 다른 지역 콘텍스트를 가지고 있기 때문이다. 코루틴과 yield from을 사용하면 이 문제가 완화된다. 스레드만큼 간단하지는 않지만, 내포된 콜백보다는 관리하기 쉬워진다.

아래 flags3_asyncio.py는 비동기식으로 국기를 내려받는 세 번째 버전으로, 국가명으로 각각의 국기 파일을 저장한다. flag2_asyncio.py에서 download_many()와 download_coro()는 그대로 유지되며, 다음 코드가 수정되었다.

---

**download_one()**
이제 이 코루틴은 yield from을 사용해서 get_flag() 및 새로 만들어진 get_country() 코루틴에 위임한다.

**get_flag()**
이 코루틴에 들어 있던 코드 대부분은 get_country()에서도 사용할 수 있도록 새로 만들어진 http_get() 코루틴으로 이동되었다.

**get_country()**
이 코루틴은 국가 코드에 대한 metadata.json 파일을 가져와서 국가명을 꺼낸다.

**http_get()**
웹에서 파일을 가져오기 위해 공통으로 사용하는 코드

---

- [flags3_asyncio.py](https://github.com/hyeonDD/fluent_python/blob/master/Part18/ex18-5/flags3_asyncio.py)
1. 콘텐트 자료형이 'json'이거나 url이 '.json'으로 끝나면, 응답 객체의 json() 메서드를 호출해서 데이터를 파싱하고 파이썬 데이터 구조체를 반환한다(여기서는 딕셔너리 객체다.)
2. 그렇지 않으면 read() 메서드를 호출해서 바이트 그대로 가져온다.
3. metadata는 JSON 콘텐츠로 만들어진 딕셔너리 객체를 받는다.
4. return yield from처럼 키워드가 나랗니 나오면 파이썬 파서가 혼동해서 오류를 발생시키므로 바깥쪽 괄호가 필요하다.
5. 가능한 한 빨리 가져오기 위해 semaphore에 의해 제어되는 두 개의 with 블록에서 get_flag()와 get_country()를 따로 호출한다.

위 에제에서는 yield from 구문이 9번 나온다. 이제는 이벤트 루프를 블로킹하지 않고 하나의 코루틴에서 다른 코루틴으로 위임하는 방법에 대해 감을 잡았을 것이라고 생각한다.

yield from을 사용해야 할 때와 yield from을 사용할 수 없을 때를 구부하는 것이 관건이다. 이에 대한 원론적인 답변은 간단하다. 코루틴 및 Task 객체 등의 asyncio.Future 객체에는 yield from을 사용해야 한다. 그러나 다음 절에서 구현하는 서버 중 하나에 사용할 StreamWriter 클래스처럼 코루틴과 일반 함수를 무작위로 혼합해서 사용하는 API의 경우에는 혼란스러울 수 있다.

위 예제로 flags2 계열의 예제를 모두 마치고자 한다. 이 코드를 다음과 같이 바꿔보면서 동시성 HTTP 클라이언트가 어떻게 작동하는지 감을 잡기 바란다. -a, -e, -l 명령행 옵션을 이용해서 내려받는 수를 조정하고, -m 옵션을 이용해서 동시에 내려받는 수를 설정한다. LOCAL, REMOTE, DELAY, ERROR 서버에 실행해보고, 각 서버별로 최대의 성능을 낼 수 있는 최적의 동시 접속 수를 찾아내보기 바란다. 그리고 vaurien_error_delay.sh 스크립트 (http://bit.ly/1f6CY6B) 의 설정을 변경해서 에러와 지연을 추가하거나 제거해보기 바란다.

이제 asyncio를 이용한 클라이언트 스크립트에서 asyncio를 이용한 서버 작성으로 넘어가자.
