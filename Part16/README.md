<!-- 
[UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part16/ex16-1/UML_class_diagram.png)
 -->
# 코루틴

영어 사전에서 'yield' 단어를 찾아보면 '생산한다'와 '양보한다'는 두 가지 뜻을 볼 수 있다. 파이썬 제너레이터에서 yield 키워드를 사용할 때, 이 두가지 의미가 모두 적용된다. 예를 들어 yield item 문장은 next()의 호출자가 받을 값을 생성하고, 양보하고, 호출자가 진행하고 또 다른 값을 소비할 준비가 되어 다음번 next()를 호출할 때까지 제너레이터 실행을 중단한다. 호출자가 제너레이터에서 값을 꺼내오는 것이다.

구문 측면에서 보면 코루틴은 제너레이터와 똑같이 본체 안에 yield 키워드를 가진 함수일 뿐이다. 그러나 코루틴에서는 datum = yield처럼 일반적으로 yield 문이 표현식의 오른쪽에 나오거나, 값을 생성하지 않는 경우도 있다. yield 키워드 뒤에 표현식이 없으면 제너레이터는 None을 생성한다. 호출자가 next() 대신 값을 전송하는 send()를 호출하면 코루틴이 호출자로부터 데이터를 받을 수 있다. 일반적으로 호출자가 코루틴에 값을 밀어 넣는다.

심지어 yield 키워드를 통해 아무런 데이터도 주고받지 않을 수 있다. 데이터의 흐름에 무관하게 yield는 실행을 제어하는 장치로서 멀티태스킹에서의 협업을 구현하기 위해 사용할 수 있다. 즉, 각 코루틴이 중앙의 스케줄러에 제어를 양보해서 다른 코루틴이 실행되게 할 수 있다.

제어 흐름의 관점에서 yield를 보는 것에 익숙해지면, 코루틴을 이해할 수 있는 마음의 준비가 된 것이다.
파이썬 코루틴은 이 책에서 지금까지 보아온 초라한 제너레이터 함수를 계속해서 개선해온 산물이다. 파이썬 코루틴의 진화를 따라가다 보면 단계별로 기능이 많아지면서 더 복잡해지는 특징을 이해하는 데 도움이 된다.

제너레이터를 어떻게 코루틴으로 만들 수 있는지 간략히 설명한 후 이 장의 핵심으로 넘어갈것이다. 그러고 나서 다음과 같은 내용을 설명한다.
* 코루틴으로 작동하는 제너레이터의 동작과 상태
* 데커레이터를 이용해서 코루틴을 자동으로 기동하기
* 제너레이터 객체의 close()와 throw()메서드를 통해 호출자가 코루틴을 제어하는 방법
* 종료할 때 코루틴이 값을 반환하는 방법
* 새로운 yield from 구문의 사용법과 의미
* 사용 예: 시뮬레이션의 동시 활동을 관리하기 위한 코루틴