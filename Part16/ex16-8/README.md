<!-- 
- [UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part16/ex16-8/UML_class_diagram.png)
 -->
# yield from의 의미
PEP 380을 개발하는 동안 이 제안서의 작성자인 그렉 이윙은 제안한 구성체의 복잡도에 대한 질문을 받았다. 그는 '거의 언제나 사람들에게 중요한 정보는 제일 앞 문장 하나에 들어있다'고 대답하면서, 그 당시 다음과 같이 작성되어 있던 PEP 380 초안의 일부를 인용한다.

**그 반복자가 또 다른 제너레이터인 경우, 하위 제너레이터의 본체가 yield from 표현식의 대상 안에 들어가는 것과 동일한 효과가 발생한다. 게다가 하위 제너레이터는 값을 가진 return 문을 이용해서 값을 반환할 수 있고, 그 값은 yield from 표현식의 값이 된다.**

이러한 위로의 말은 더 이상 PEP에 들어 있지 않다. 극단적인 사례를 모두 설명하지 않기 때문이다. 그렇지만 처음으로 접근하는 설명으로서는 나쁘지 않다.

승인된 PEP 380에서는 제안 부분 (https://www.python.org/dev/peps/pep-0380/#proposal) 에서 6개의 항목으로 yield from의 동작을 설명한다. 다음은 제안서의 내용을 거의 그대로 옮겼지만, '반복자'라는 말을 '하위 제너레이터'로 변경하고, 말을 약간 다듬었다. [coroaverager3.py](https://github.com/hyeonDD/fluent_python/blob/master/Part16/ex16-7/coroaverager3.py)은 다음 네 가지 특징을 보여준다.
* 하위 제너레이터가 생성하는 값은 모두 대표 제너레이터의 호출자(즉, 클라이언트)에 바로 전달된다.
* send()를 통해 대표 제너레이터에 전달한 값은 모두 하위 제너레이터에 직접 전달된다. 값이 None이면 하위 제너레이터의 __next__() 메서드가 호출된다. 전달된 값이 None이 아니면 하위 제너레이터의 실행이 재개된다. 그 외의 예외는 대표 제너레이터에 전달된다.
* 제너레이터나 하위 제너레이터에서 return expr 문을 실행하면, 제너레이터를 빠져나온 후 StopIteration(expr) 예외가 발생한다.
* 하위 제너레이터가 실행을 마친 후 발생한 StopIteration 예외의 첫 번째 인수가 yield from 표현식의 값이 된다.

yield from의 나머지 특징 두 가지는 예외와 종료에 관련되어 있다.
* 대표 제너레이터에 던져진 GeneratorExit 이외의 예외는 하위 제너레이터의 throw() 메서드에 전달된다. throw() 메서드를 호출해서 StopIteration 예외가 발생하면 대표 제너레이터의 실행이 재개된다. 그 외의 예외는 대표 제너레이터에 전달된다.
* GeneratorExit 예외가 대표 제너레이터에 던져지거나 대표 제너레이터의 close() 메서드가 호출되면 하위 제너레이터의 close() 메서드가 호출된다. 그 결과 예외가 발생한 예외가 대표 제너레이터에 전파된다. 그렇지 않으면 대표 제너레이터에서 GeneratorExit 예외가 발생한다.

yield from의 세부적인 의미는 미묘하다. 특히 예외를 처리하는 부분이 글허다. 그렉 이윙은 이렇게 미묘한 작동을 PEP 380에 잘 설명하고 있다.

그렉 이윙은 또한 파이썬과 비슷한 의사코드를 이용해서 yield from의 작동을 문서화했다. 필자는 개인적으로 PEP 380의 의사코드를 분석해보는 것이 도움이 된다고 생각한다.그러나 의사코드의 길이가 40줄이나 되므로 한눈에 바로 이해하기는 쉽지 않을 것이다.

그런 의사코드를 분석해야 할 때는 먼저 yield from의 가장 기본적이고 일반적인 사례를 가정해서 따라가는 것이 좋다.

yield from이 대표 제너레이터 안에 있다고 생각하자. 클라이언트 코드는 대표 제너레이터를 움직이고, 대표 제너레이터는 하위 제너레이터를 움직인다. 그리고 관련된 논리를 단순화하기 위해 클라이언트가 대표 제너레이터의 throw()나 close()를 결코 호출하지 않는다고 가정하자. 그리고 하위 제너레이터가 실행을 마칠 때까지 에외를 발생시키지 않고, 실행을 마친 후에는 인터프리터가 StopIteration 예외를 발생시킨다고 가정하자.

[coroaverager3.py](https://github.com/hyeonDD/fluent_python/blob/master/Part16/ex16-7/coroaverager3.py)의 예제는 이러한 단순한 가정을 기반으로 작성한 코드다. 사실 실제 코드에서는 대표 제너레이터가 실행을 완료해야 한다. 어쨋든 이렇게 단순한 세상에서는 yield from이 어떻게 작동하는지 살펴보자.

아래 코드의 의사코드는 대표 제너레이터에서 다음 문장 하나를 확장한 것과 대등하다.
```
RESULT = yield from EXPR
```

아래 예제의 처리 흐름을 차분히 따라가 보라.
```
_i = iter(EXPR) #1
try:
    _y = next(_i) #2
except StopIteration as _e:
    _r = _e.value #3
else:
    while 1: #4
        _s = yield _y #5
        try:
            _y = _i.send(_s) #6
        except StopIteration as _e: #7
            _r = _e.value
            break

RESULT = _r #8
```
1. 반복자 _i(하위 제너레이터)를 가져오기 위해 iter() 함수를 적용하므로, 어떠한 반복형도 EXPR로 사용할 수 있다.
2. 하위 제너레이터를 기동시킨다. 반환된 값은 _y에 저장되어 최초의 생성 값으로 사용된다.
3. StopIteration이 발생하면 예외 객체에서 value 속성을 꺼내 _r에 할당한다. 이 값이 가장 간단한 경우의 RESULT 값이 된다.
4. 이 루프를 실행하는 동안 대표 제너레이터는 실행이 중단되고 단지 호출자와 하위 제너레이터 간의 통로 역할만 수행한다.
5. 하위 제너레이터에서 생성된 값을 그대로 생성하고, 호출자가 보낼 _s를 기다린다. 이 코드 안에서 유일하게 사용된 yield 문이라는 점에 주의하라.
6. 호출자가 보낸 _s를 하위 제너레이터에 전달하면서 하위 제너레이터의 실행을 진행시키낟.
7. 하위 제너레이터가 StopIteration 예외를 발생시키면, 예외 객체 안의 value 속성을 가져와서 _r에 할당하고, 루프를 빠져나온 후, 대표 제너레이터의 실행을 재개한다.
8. _r이 전체 yield from 표현식의 값이 되어 RESULT에 저장된다.

이 간단한 의사코드에서 필자는 PEP 380에 사용된 의사코드의 원래 변수명을 유지했다. 여기에 사용된 변수는 다음과 같다.

---

**_i (iterator)**
하위 제너레이터

**_y (yielded)**
하위 제너레이터가 생성한 값

**_r (result)**
최종 결과값 (즉, 하위 제너레이터가 종료된 후 yield from 표현식의 값)

**_s (sent)**
호출자가 대표 제너레이터에 보낸 값. 하위 제너레이터에 전달된다.

**_e (exception)**
예외 (이 간단한 의사코드에서는 StopIteration 객체만 발생한다.)

---

throw()와 close()를 처리하지 않는 것 외에도, 단순화한 의사코드에서는 클라이언트에 의한 next()와 send() 호출을 하위 제너레이터에 전달하기 위해 (send)만 사용하고 있다. 일단 처음 구조를 파악할 때는 next()와 send()의 구분에 신경 쓸 필요 없다. 앞에서 이야기한 것처럼 yield from이 위 예제의 단순화한 의사코드에서 보여준 것만 처리하는 경우에는 [coroaverager3.py](https://github.com/hyeonDD/fluent_python/blob/master/Part16/ex16-7/coroaverager3.py)도 제대로 작동한다.

그러나 클라이언트가 호출하는 throw()나 close()를 지원하지 않는 단순한 반복형일 수 있으므로 이런 경우에는 yield from 논리에서 처리해야 한다. 즉, 하위 제너레이터가 이 메서드들을 구현하지 않으면, 하위 제너레이터에서 예외가 발생하고, 이 예외를 yield from 장치에서 처리해야 한다. 하위 제너레이터에서 예외가 발생하고, 이 예외를 yield from 장치에서 처리해야 한다. 하위 제너레이터는 호출자가 의도하지 않았던 예외도 발생시킬 수 있으며, 이 예외도 yield from 구현에서 처리해야 한다. 마지막으로, 최적화하기 위해 호출자가 호출하는 next()와 send(None)은 모두 하위 제너레이터의 next()를 호출한다. 호출자가 None이 아닌 값으로 send()를 호출할 때만 하위 제너레이터의 send() 메서드가 사용된다.

이제 이 논리를 제대로 이해하기 위해 PEP 380에서 설명하는 yield from을 확장한 전체 의사코드를 가져와서 설명한다. 아래예제는 대표 제너레이터에서 사용된 다음의 한 줄짜리 코드를 확장한 것으로서, 코드는 그대로 가져왔고 번호 설명은 필자가 추가한 것이다.
```
RESULT = yield from EXPR
```

```
# 대표 제너레이터에서 RESULT = yield from EXPR 문과 대등한 의사코드
_i = iter(EXPR) #1
try:
    _y = next(_i) #2
except StopIteration as _e:
    _r = _e.value #3
else:
    while 1: #4
        try:
            _s = yield _y #5
        except GeneratorExit as _e: #6
            try:
                _m = _i.close
            except AttributeError:
                pass
            else:
                _m()
            raise _e
        except BaseException as _e: #7
            _x = sys.exc_info()
            try:
                _m = _i.throw
            except AttributeError:
                raise _e
            else: #8
                try:
                    _y = _m(*_x)
                except Stopiteration as _e:
                    _r = _e.value
                    break
        else: #9
            try: #10
                if _s is None: #11
                    _y = next(_i)
                else:
                    _y = _i.send(_s)
            except StopIteration as _e: #12
                _r = _e.value
                break
RESULT = _r #13
```
1. 반복자 _i(하위 제너레이터)를 가져오기 위해 iter() 함수를 적용하므로, 어떠한 반복형도 EXPR로 사용할 수 있다.
2. 하위 제너레이터를 기동시킨다. 반환된 값은 _y에 저장되어 최초의 생성 값으로 사용된다.
3. StopIteration이 발생하면 예외 객체에서 value 속성을 꺼내 _r에 할당한다. 이 값이 가장 간단한 경우의 RESULT 값이 된다.
4. 이 루프를 실행하는 동안 대표 제너레이터는 실행이 중단되고 단지 호출자와 하위 제너레이터 간의 통로 역할만 수행한다.
5. 하위 제너레이터에서 생성된 값을 그대로 생성하고, 호출자가 보낼 _s를 기다린다. 이 코드 안에서 유일하게 사용된 yield문 이라는 점에 주의하라.
6. 대표 제너레이터에서 하위 제너레이터의 종료를 처리한다. 모든 반복형이 하위 제너레이터가 될 수 있으므로, 하위 제너레이터에 close() 메서드가 없을 수도 있다.
7. 호출자가 throw()로 던진 예외를 처리한다. 하위 제너레이터가 throw() 메서드를 구현하지 않을 수도 있는데, 이 경우 대표 제너레이터에서 예외가 발생한다.
8. 하위 제너레이터가 throw() 메서드를 가진 경우, 호출자로부터 받은 예외를 이용해서 호출한다. 하위 제너레이터는 예외를 처리하거나(이 경우 루프가 계속 실행된다), StopIteration 예외를 발생시키거나(이 예외에서 _r 결과를 추출하고 루프를 종료한다), 여기에서 처리할 수 없는 예외를 발생시킬 수도 있다(이 예외는 대표 제너레이터로 전파된다).
9. 생성할 때 예외가 발생하지 않은 경우다.
10. 하위 제너레이터를 계속 실행시킨다.
11. 최근에 호출자로부터 받은 값이 None이면 하위 제너레이터의 next()를 호출하고, 그 외의 경우에는 send()를 호출한다.
12. 하위 제너레이터가 StopIteration 예외를 발생시키면, 예외 객체 안의 value 속성을 가져와서 _r에 할당하고, 루프를 빠져나온 후, 대표 제너레이터의 실행을 재개한다.
13. _r이 전체 yield from 표현식의 값이 되어 RESULT에 저장된다.

yield from 의사코드는 논리의 대부분은 최대 4단계까지 들어가는 6개의 try/except 블록에서 구현되므로 이해하기 약간 복잡하다. 그 외 while 키워드가 1개, if가 1개, yield가 1개 사용되었다. while, yield, next(), send()에 주의해서 살펴보면 전체적인 구조를 이해하는 데 도움이 될 것이다.

예제의 2번 설명을 보면 하위 제너레이터를 기동함을 알 수 있다. 따라서 16.4절 '코루틴을 기동하기 위한 데커레이터'에서 설명한 자동 기동 데커레이터는 yield from과 함께 사용할 수 없다. 이 절을 시작할 때 인용했던 메시지 (http://bit.ly/1JIopTu) 에서 그렉 이윙은 yield from의 의사코드에 대해 다음과같이 설명한다.

**의사코드로 확장한 것을 분석해서 yield from 구문의 의미를 이해하라는 것은 아니다. 의사코드는 단지 언어 변호사에게 필요한 모든 세부사항을 확정하기 위한 것일 뿐이다.**

여러분의 학습 스타일에 따라 의사코드 확장에 대해 꼼꼼히 따져보는 것이 그리 도움이 되지 않을 수도 있다. yield from을 활용한 실제 코드를 연구하는 것이 의사코드 구현을 뚫어지게 쳐다보는 것보다 도움이 될 것이다. 그러나 필자가 본 거의 모든 yield from 예제는 asyncio 모듈을 이용한 비동기 프로그래밍과 관련되어 있어서, 활설화된 이벤트 루프에 의존해서 작동한다. 18장에서 yield from을 아주 많이 보게 된다. 그리고 16.11절 '읽을거리'에는 이벤트 루프 없이 yield from을 사용하는 재미있는 코드 몇 개에 대한 링크가 있다.

이제 코루틴 사용법의 고전적인 예제인 시뮬레이션 구현으로 넘어가자. 이 예제에서는 yield from을 사용하지 않지만, 단일 스레드에서 동시에 발생하는 활동을 관리하기 위해 코루틴을 사용하는 방법을 보여준다.
            

