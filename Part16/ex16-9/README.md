<!-- 
- [UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part16/ex16-9/UML_class_diagram.png)
 -->
# 사용 사례: 이산 이벤트 시뮬레이션을 위한 코루틴

이 절에서는 코루틴과 표준 라이브러리 객체만 이용해서 구현한 아주 간단한 시뮬레이션을 설명한다. 시뮬레이션은 컴퓨터 과학 문헌에서 코루틴을 응용하는 고전적이 사례다. 최초의 객체 지향 언어인 Simula는 시뮬레이션을 간결하게 표현하기 위해 코루틴 개념을 소개했다.
>다음에 나오는 시뮬레이션 예제들은 학문적 연구를 위한 것이 아니다. 코루틴은 ayncio 패키지의 핵심 기반이다. 여기에서 설명하는 시뮬레이션은 스레드 대신 코루틴을 이용해서 동시에 발생하는 활동을 구현하는 방법을 보여준다. 이 내용은 18장에서 asyncio를 처리할 때 많은 도움이 될 것이다.

예제에 들어가기 전에 시뮬레이션에 대해 간단히 정리해보자.

## 이산 이벤트 시뮬레이션에 대해
이산 이벤트 시뮬레이션(DES)은 시스템을 일련의 이벤트로 모델링한다. DES에서 시뮬레이션 '시계'는 고정된 값만큼 진행하는 것이 아니라, 모델링된 다음 이벤트의 시뮬레이션된 시각으로 바로 진행한다. 예를 들어 상위 수준 관점에서 택시 운행을 시뮬레이션하는 경우, 승객을 태우는 이벤트 다음의 이벤트는 승객을 내리는 이벤트다. 운행 시간이 5분이든 50분이든 중요하지 않다. 승객을 내리는 이벤트가 발생하면 운행을 마친 시간으로 시계를 갱신한다. DES의 경우 1년치 택시 운행을 1초 안에 시뮬레이션할 수 있다. 이 방식은 고정된(그리고 일반적으로 아주 짧은) 시간만큼 시계를 연속적으로 진행하는 연속 시뮬레이션과 대비된다.

이산 이벤트 시뮬레이션에 대한 설명을 들으며, 바로 턴제 게임을 떠올렷을 것이다. 게임 상태는 플레이어가 말을 움직일 때만 변경되고, 어디로 움직일지 고민하는 동안 시뮬레이션 시계는 멈춘다. 한편 실시간 게임은 연속 시뮬레이션으로서, 시뮬레이션 시계가 계속 실행되면서 일초에도 몇 번씩 게임 상태가 갱신되므로, 느린 플레이어는 정말 불리한 입장에 놓인다.

이 두 종류의 시뮬레이션은 모두 이벤트 루프에 의해 작동하는 콜백이나 코루틴 등의 객체지향 프로그래밍 기법을 이용해서 다중 스레드나 단일 스레드로 구현할 수 있다. 실시간으로 동시에 발생하는 행동을 표현하기 위해 여러 스레드를 이용해서 연속 시뮬레이션을 구현하는 방법이 단연코 가장 자연스러울 것이다. 한편 코루틴은 DES를 작성하기 위한 추상화에 딱 맞는다. SimPy는 시뮬레이션의 각 프로세스를 표현하기 위해 하나의 코루틴을 사용하는 파이썬용 DES 패키지다.
> 시뮬레이션 분야에서 '**프로세스**'라는 용어는 모델 객체의 행동을 말하며, OS 프로세스를 말하는 것이 아니다. 시뮬레이션 프로세스를 OS 프로세스로 구현할 수도 있지만, 모델 객체의 행동은 일반적으로 스레드나 코루틴으로 구현한다.

시뮬레이션에 관심이 있다면 SimPy는 연구해볼 가치가 있다. 그러나 이 절에서는 표준 라이브러리 기능만 사용해서 구현한 아주 간단한 DES를 설명한다. 여기서는 코루틴을 이용해서 동시에 수행되는 행동을 프로그래밍하는 것을 이해하는 데 주안점을 두고 있다. 다음 절은 신경 써서 공부해야 하지만, 마치고 나면 asyncio, Twisted, Toronado 등의 라이브러리가 단일 스레드를 이용해서 어떻게 동시에 일어나는 활동을 관리하는지 깊이 있게 이해할 수 있을 것이다.

## 택시 집단 시뮬레이션
우리가 구현할 시뮬레이션 프로그램 taxi_sim.py에서는 아주 많은 택시를 생성한다. 각 택시는 일정 횟수의 운행을 마친 후 집으로 돌아간다. 택시는 차고를 나와 승객을 찾으면서 '배회'한다. 이 상태는 승객을 태울 때까지 계속되며, 그러고 나서 운행이 시작된다. 승객이 내리고 나면, 택시는 다시 배회 상태로 들어간다.

택시가 배회하고 운행하는 시간은 지수 분포를 이용해서 생성한다. 간결하게 출력하기 위해 분단위 시간을 사용하지만, 실수형 시간을 이용해서 시뮬레이션할 수도 있다. 각 상태의 상태 변화는 이벤트로 나타난다. 아래그림은 프로그램을 실행한 하나의 예를 보여준다.

아래그림에서는 세 대의 택시에 의한 운행이 서로 얽혀 있다는 점에 주의하라. 택시 운행을 파악하기 쉽게 직접 화살표를 그려 넣었다. 각 화살표는 승객이 탄 시점에 시작해서 승객이 내린 시점에 끝난다. 이 모습은 동시에 수행하는 행동을 관리하기 위해 코루틴을 사용할 수 있는 방법을 잘 보여준다.

![taxi실행사진](https://github.com/hyeonDD/fluent_python/blob/master/Part16/ex16-9/taxi.png)

위 그림과 관련해서 다음 사항에 주의하라.
* 각 택시는 앞 차가 출발한지 5분 후에 차고를 출발한다.
* 첫 승객을 태우기까지, 택시0은 2분(time=2), 택시1은 3분(time=8), 택시2는 5분(time=15) 걸렸다.
* 택시0은 두 번의 운행을 했다(진한 선). 첫 번째 운행은 time=2에서 시작해서 time=18에 끝났고, 두 번째는 time=28에 시작해서 time=65에 끝났다(이 시뮬레이션에서 가장 긴 운행).
* 택시1은 네 번의 운행을 하고(점선) time=110에 집으로 돌아갔다.
* 택시2는 여섯 번의 운행을 하고(흐린 선) time=109에 집으로 돌아갔다. 마지막 운행은 time=97에서 시작해서 1분 만에 끝났다.
* 택시1이 time=8에 시작해서 처음 운행하는 동안, 택시2는 time=10에 차고를 나와서 두 번의 운행을 마쳤다.
* 이 간단한 시뮬레이션에서, 마지막 이벤트가 time=110에 발생하면서 모든 이벤트가 기본 설정된 180분안에 완료되었다.

대기하고 있는 이벤트를 남겨 놓고 시뮬레이션이 끝날 수도 있다. 이벤트가 남아 있는 경우에는 다음과 같은 메시지가 출력된다.
```
*** end of simulation time: 3 events pending ***
```
taxi_sim.py의 전체 소스 코드는 [예제 A-6]에 있다. 이 장에서는 코루틴을 공부하기 위해 필요한 부분만 보여준다. 이 코드에서는 코루틴의 taxi_process()와 시뮬레이션의 핵심 루프를 실행하는 Simulator.run()이 가장 중요하다.

아래 에제는 taxi_process() 코드를 보여준다. 이 코루틴에서는 다른 곳에서 정의된 compute_delay()함수 (시간 간격을 분 단위로 변환)와 Event 클래스 객체를 사용한다. Event 클래스는 다음과 같이 namedtuple로 정의되어 있다.
```
Event = collections.namedtupel('Event', 'time proc action')
```
Event 객체 안의 time은 이벤트가 발생할 시각, proc는 택시 프로세스의 객체의 식별자, action은 행동을 설명하는 문자열이다.

이제 아래예제에 있는 taxi_process() 코드를 자세히 살펴보자.

- [taxi_sim0.py]](https://github.com/hyeonDD/fluent_python/blob/master/Part16/ex16-9/taxi_sim0.py)
1. taxi_process()는 각 택시마다 한 번씩 호출되어 택시의 행동을 나타내는 제너레이터 객체를 생성한다. ident는 택시 번호(여기서는 0, 1, 2), trips는 집에 돌아가기 전에 이 택시가 수행할 운행 횟수, start_time은 택시가 차고를 나오는 시각이다.
2. 첫 번째 생성된 Event는 'leave garage'다. yield를 실행하므로 코루틴이 중단되고, 시뮬레이션의 핵심 루프가 예약된 다음 이벤트를 진행할 수 있게 해준다. 이 프로세스를 다시 활성화해야 할 때가 되면, 핵심 루프는 time에 할당된 현재 시각을 보내준다.
3. 각 운행마다 이 블록이 한 번씩 반복 실행된다.
4. 승객을 태우는 Event가 생성되고, 코루틴은 여기에서 실행을 일시 중단한다. 이 코루틴을 다시 활성화할때가 되면 핵심 루프가 다시 현재 시각을 보낸다.
5. 승객을 내리는 Event가 생성되고, 다시 활성화되어야 할 시각을 핵심 루프에서 보내줄 때까지 코루틴은 여기에서 실행을 일시 중단한다.
6. 주어진 횟수만큼 운행을 한 후에는 for 루프가 끝나고, 마지막 'going home' 이벤트가 생성된다. 코루틴은 여기에서 마지막으로 일시 중단된다. 재활성화될 때 핵심 루프가 코루틴에 시각을 보내지만, 사용하지 않을 것이므로 이 값은 저장하지 않는다.
7. 코루틴이 끝까지 실행되면 제너레이터 객체가 StopIteration 예외를 발생시킨다.

파이썬 콘솔에서 taxi_process()를 호출하여 여러분이 직접 택시를 운행해볼 수도 있다. 어떻게 하는지 아래 예제를 보자.

```
from taxi_sim import taxi_process
taxi = taxi_process(ident=13, trips=2, start_time=0) #1
next(taxi) #2
# Event(time=0, proc=13, action='leave garage')
taxi.send(_.time + 7) #3
# Event(time=7, proc=13, action='pick up passenger') #4
taxi.send(_.time + 23) #5
# Event(time=30, proc=13, action='drop off passenger')
taxi.send(_.time + 5) #6
# Event(time=35, proc=13, action='pick up passenger')

taxi.send(_.time + 48) #7
# Event(time=83, proc=13, action='drop off passenger')
taxi.send(_.time + 1)
# Event(time=84, proc=13, action='going home') #8
taxi.send(_.time + 10) #9
"""
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
StopIteration
"""
```
1. indent=13으로 설정된 택시를 나타내는 제너레이터 객체를 생성한다. 이 택시는 t=0에 시작해서 두 번 운행한다.
2. 코루틴을 기동시킨다. 그러면 코루틴은 초기 이벤트를 생성한다.
3. 이제 현재 시각을 코루틴에 보낼(send) 수 있다. 콘솔에서 _ 변수는 마지막 결과값에 바인딩된다. 여기에서는 7을 더했으므로, 택시가 7분 후에 첫 번째 승객을 태우게 된다.
4. for 루프를 처음 실행하면서 생성된다.
5. 현재 운행 중이므로 _.time + 23을 보내면 첫 번째 승객을 위한 운행 시간이 2분 걸린다는 의미다.
6. 그러고 나서 택시가 5분간 배회한다.
7. 마지막 운행은 48분 걸린다.
8. 두 번의 운행을 마친 후 for 루프가 종료되어 'going home' 이벤트가 생성된다.
9. 코루틴에 send()를 호출하면 코루틴의 실행이 완료된다. 코루틴이 반환될 때 인터프리터가 StopIteration에외를 발생시킨다.

위 예제에서는 콘솔을 이용해서 시뮬레이션 핵심 루프를 흉내 냈다. 택시 코루틴이 생성한 Event 객체의 time 속성을 가져와서, 임의의 숫자를 더한 후, 그 합계를 코루틴을 다시 활성화하기 위해 taxi.send()를 호출하는 데 사용했다. 시뮬레이션에서는 Simulation.run() 메서드의 핵심 루프에서 taxi 코루틴을 다시 활성화시킨다. 시뮬레이션 '시계'는 sim_time 변수에 저장되어 이벤트가 생설될 때마다 갱신된다.

Simulator 클래스의 객체를 생성하기 위해 taxi_sim.py의 main() 함수는 다음과 같이 taxis딕셔너리를 만든다.
```
taxis = {i: taxi_process(i, (i +1) * 2, i * DEPARTURE_INTERVAL
         for i in range(num_taxis))}
sim = Simulator(taxis)
```
DEPARTRUE_INTERVAL은 5며, 예제에서 num_taxis가 3이므로, 다음 코드와 동일하다.
```
taxis = {0: taxi_process(ident=0, trips=2, start_time=0),
         1: taxi_process(ident=1, trips=4, start_time=5),
         2: taxi_process(ident=2, trips=6, start_time=10)}
sim = Simulator(taxis)
```
따라서 taxis 딕셔너리의 변수에는 서로 다른 매개변수를 가진 별개의 제너레이터 객체 3개가 들어간다. 에를 들어 택시1은 start_time=5에 시작해서 운행을 4번 한다. 이 taxis 딕셔너리만 있으면 Simulaotr 객체를 생성할 수 있다.

아래 에제는 Simulaotr 클래스의 __init__() 메서드를 보여준다. Simulator의 주요 데이터 구조체는 다음과 같다.

---

**self.events**
Event 객체를 담고 있는 PriorityQueue 객체. PriorityQueue는 항목을 넣고 나서 정렬된 순서대로 꺼내온다. Eventnamedtuple 객체의 경우 time 속성으로 정렬한다.

**self.procs**
각 프로세스 번호를 시뮬레이션의 활성화된 프로세스로 매핑한다. 이 시뮬레이션에서는 택시 하나를 나타내는 제너레이터 객체를 하나의 프로세스로 표현한다. 이 변수는 앞에서 본 taxis 딕셔너리에 바인딩된다.

---

```
#taxi_sim.py:Simulator 클래스 초기화 메서드
class Simulator:
    def __init__(self, procs_map):
        self.events = queue.PriorityQueue() #1
        self.procs = dict(procs_map) #2
```
1. PriorityQueue는 예정된 이벤트를 시간순으로 정렬해서 보관한다.
2. 딕셔너리형의 procs_map 인수를 받지만, 여기에서 다시 딕셔너리 객체를 만들어 사본을 보관한다. 시뮬레이션이 실행되면 집으로 돌아가는 택시들이 self.procs에서 제거되지만, 클라이언트가 전달한 객체를 변경하면 안 되기 때문이다.

우선순위 큐는 이산 이벤트 시뮬레이션의 핵심 기반이다. 이벤트를 무작위 순서로 만들어 큐에 넣은 후, 예정된 시각순으로 이벤트를 꺼내 와야 하기 때문이다. 예를 들어 다음과 같이 두 개의 이벤트를 큐에 넣는다고 생각해보자.
```
Event(time=14, proc=0, action='pick up passenger')
Event(time=11, proc=1, action='pick up passenger')
```
즉, 탟0은 14분에 첫 번째 승객을 태우는 반면, 택시1은 11분(10분에 차고에서 나오므로, 차고에서 나온 지 1분 후)에 승객을 태운다. 이 두 이벤트를 우선순위 큐에 넣으면 시뮬레이터의 핵심 루프는 Event(time=11, proc=1, action='pick up passenger') 객체를 먼저 가져오게 된다.

이제 시뮬레이션의 핵심 알고리즘인 Simulator.run() 메서드를 살펴보자. 이 메서드는 main() 함수에서 다음과 같이 Simulator 객체를 생성한 직후에 호출된다.
```
sim = Simulator(taxis)
sim.run(end_time)
```
아래 예제의 Simulator 클래스에 번호 설명이 붙어 있지만, Simulator.run()의 알고리즘을 상위 수준에서 정리하면 다음과 같다.

1. 택시를 나타내는 프로세스를 반복한다.
    1. next()를 호출해서 각 택시에 대한 코루틴을 기동시킨다. 그러면 각 택시에 대한 첫 번째 이벤트가 생성된다.
    2. Simulator의 self.events 큐에 각각의 이벤트를 저장한다.
2. sim_time < end_time인 동안 시뮬레이션 핵심 루프를 실행한다.
    1. self.events가 비어 있으면 루프를 빠져나간다.
    2. self.events에서 current_event를 가져온다. 이 객체는 PriorityQueue에서 가장 작은 time 값을 가진 Event 객체다.
    3. Event를 출력한다.
    4. current_event의 time 속성으로 시뮬레이션 시각을 설정한다.
    5. current_event의 proc 속성으로 알아낸 코루틴에 시각을 보낸다. 그러면 코루틴이 next_event를 생성한다.
    6. next_event를 self.events 큐에 추가해서 스케줄링한다.

Simulator 클래스의 전체 코드는 아래 코드다.
- [taxi_sim.py]](https://github.com/hyeonDD/fluent_python/blob/master/Part16/ex16-9/taxi_sim.py)
1. run()은 시뮬레이션의 end_time을 인수로 받는다.
2. sorted() 함수를 사용해서 키로 정렬된 self.procs를 가져온다. 키는 신경 쓰지 않으므로 _를 할당한다.
3. next(proc)은 각 코루틴을 첫 번째 yield까지 실행해서 데이터를 전송할 준비를 한다. 이때 Event가 생성된다.
4. 각 이벤트를 self.events 우선순위 큐에 넣는다. [예제16-20]에서 본 것처럼 각 택시에 처음 보내는 이벤트는 'leave gargage'다.
5. 시뮬레이션 시계 sim_time을 0으로 설정한다.
6. 시뮬레이션의 핵심 루프다. sim_time이 end_time보다 작으면 반복한다.
7. 큐 안에 남아 있는 이벤트가 없을 때도 핵심 루프를 빠져나온다.
8. 우선순위 큐에서 time 값이 가장 작은 이벤트를 가져와서 current_event에 저장한다.
9. Event 데이터를 언패킹한다. 이 코드는 이벤트가 발생한 시각을 반영해서 시뮬레이션 시계인 sim_time을 갱신한다.
10. 택시의 ID에 따라 들여 써서 이벤트를 출력한다.
11. self.procs 딕셔너리에서 활성화된 택시에 대한 코루틴을 가져온다.
12. 이전 행동('pick up passenger'나 'drop off passenger')에 compute_duration()을 호출한 결과에 sim_time을 더해서 다음 활성화 시각을 계산한다.
13. 택시 코루틴에 시각을 전송한다. 코루틴은 next_event를 반환하거나, 실행이 완료된 경우 StopIteration예외를 발생시킨다.
14. StopIteration 예외가 발생하면 self.procs 딕셔너리에서 해당 코루틴을 제거한다.
15. 예외가 발생하지 않으면 next_event를 큐에 넣는다.
16. 시뮬레이션 시간이 초과되어서 루프가 종료된 경우에는 대기 중인 이벤트 수를 출력한다.

위 예제의 Simulator.run() 메서드에는 if 문 이외에서 else 블록을 사용한 코드가 두군데 있다(15장 참조).
* 핵심 while 루프에 else 블록이 연결되어 있다. 이벤트가 소진된 경우가 아니라 end_time에 도달한 경우이므로 별도의 메시지를 출력한다.
* while 루프 안의 마지막 try 문은 현재 택시 프로세스에 next_time을 전송해서 next_event를 가져온다. 그러고 나서 이 연산이 성공하면 else 블록에서 next_event를 self.events 큐에 추가한다.

필자는 이런 else 블록이 없었다면 코드의 가독성이 약간 떨어졌을 것이라고 생각한다.

이 에제에서는 이벤트를 처리하고 코루틴에 데이터를 전송해서 코루틴을 실행시키는 루프를 보여주고자 했다. 이 구조는 18장에서 설명할 asyncio의 기반 개념이 된다.