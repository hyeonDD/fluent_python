<!-- 
- [UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part14/ex14-10/UML_class_diagram.png)
 -->
# 파이썬 3.3의 새로운 구문: yield from

다른 제너레이터에서 생성된 값을 상위 제너레이터 함수가 생성해야 할 때는 전통적으로 중첩된 for 루프를 사용했다.
예를 들어 다음 코드는 제너레이터를 연결하는 코드를 수작업으로 구현한 것이다.

```
def chain(*iterables):
    for it in iterables:
        for i in it:
            yield i

s = 'ABC'
t = tuple(range(3))
list(chain(s, t))
# ['A', 'B', 'C', 0, 1, 2]
```
chain() 제너레이터 함수는 입력받은 각각의 반복형에 차례대로 위임한다. 'PEP 380 - 하위제너레이터에 위임하기 위한 구문' 제안서 (http://bit.ly/1wpQv0i) 는 이러한 작업을 수행하는 구문(아래 콘솔 리스트)를 소개했다.
```
def chain(*iterables):
    for i in iterables:
        yield from i
list(chain(s, t))
# ['A', 'B', 'c', 0, 1, 2]
```
여기에서 볼 수 있는 것처럼 yield from i 문이 내부 for 루프를 완전히 대체한다. 이 에제에서 사용한 yield from은 올바르고 가독성도 좋지만, 단순한 편리 구문처럼 보인다. 루프를 대체하는 일 외에도 yield from은 외부 제네레이터의 호출자와 내부 제너레이터를 연결하는 통로를 만든다. 제너레이터를 코루틴으로 사용해서 호출자 코드에 값을 생성해줄 뿐만 아니라 호출자 코드에서 가져온 값을 소비하는 경우에는 이 통로가 정말 중요해진다. 16장에서는 코루틴을 살펴보면서 yield from 이 단순한편리 구문이 아닌 이유를 여러 페이지에 걸쳐 자세히 설명한다.

yield from에 대해 간략히 알아봤으니, 이제 표준라이브러리에서 반복형을 잘 처리하는 함수들을 살펴보자.

# 반복형을 리듀스하는 함수.
아래표의 함수는 모두 반복형을 입력받아 하나의 값을 반환한다. 이 함수는 흔히 '리듀스', '폴딩', 혹은 '누적' 함수라고 한다. 사실 여기에 나열된 함수는 모두 functools.reduce() 함수로 구현할 수 있지만, 자주 발생하는 특정 문제를 쉽게 처리하기 때문에 별도의 내장형 함수로 존재한다. 그리고 all()과 any()는 단락 평가 함수로서, reduce()로 최적화할 수 없다. 단락 평가를 하는 경우에는 결과가 확정되는 즉시 반복자 소비를 중단한다. 아래예제에서 마지막 any() 테스트(끝에서 두 번째)를 보라.

| 모듈 | 함수 | 설명 |
| :--- | :--- | :--- |
| 내장 | all(it) | it의 모든 항목이 참된 값이면 True를, 아니면 False를 반환한다. all([])은 True를 반환한다. |
| 내장 | any(it) | it의 항목들 중 하나라도 참된 값이면 True를, 아니면 False를 반환한다. any([])는 False를 반환한다. |
| 내장 | max(it, [key=,] [default=]) | it의 항목들 중 최댓값을 반환한다. key는 sorted()에서 사용하는 정렬 함수와 동일한 함수며, it가 비어 있을 때는 default가 반환된다. max(arg1, arg2, ..., [key=?]형태로 호출할 수도 있으며, 이때 인수들 중 최댓값이 반환된다.) |
| 내장 | min(it, [key=,] [default=]) | it의 항목들 중 최솟값을 반환한다. key는 sorted()에서 사용하는 정렬 함수와 동일한 함수며, it가 비어 있을 때는 default가 반환된다. min(arg1, arg2, ...,, [key=?]형태로 호출할 수도 있으며, 이때 인수들 중 최솟값이 반환된다.) |
| functools | reduce(func, it, [initial]) | 처음 두 개의 항목에 func를 적용하고, 그 결과와 세 번째 항목에 또 func를 적용하는 과정을 반복한 결과를 반환한다. inittial이 주어지면 initial과 첫 항목에 func를 적용하면서 시작한다. |
| 내장 | sum(it, start=0) | it 항목의 합계에 선택적인 start 값을 더한 값을 반환한다. 실수형의 경우 math.fsum()을 사용하면 정밀도가 향상된다. |

아래 예제는 all()과 any()의 사용 예를 보여준다.
```
# 어떤 시퀀스에 all()과 any()를 적용한 결과
all([1, 2, 3])
# True
all([1, 0, 3])
# False
all([])
# True
any([1, 2, 3])
# True
any([1, 0, 3])
# True
any([0, 0.0])
# False
any([])
# False
g = (n for n in [0, 0.0, 7, 8])
any(g)
# True
next(g)
# 8
```
functools.reduce() 에 대해서는 10.6절 'Vecotor 버전 #4: 해싱 및 더 빠른 =='에 아주 자세히 설명되어 있다.

sorted()도 반복형을 입력받아서 정렬된 것을 반환하는 내장 함수다. sorted()는 제너레이터 함수인 reversed()와 달리 실제 리스트를 만들어서 반환한다. 어쨋든 입력된 반복형의 항목을 모두 읽어야 정렬할 수 있고, 정렬이 리스트 안에서 발생하므로, sorted()는 정렬을 완료한 후 그 리스트를 바로 반환한다. sorted() 함수가 모든 반복형을 소비할 수 있으므로 여기에서 설명한 것이다.

물론 sorted()와 리듀스 함수는 유한 반복형에만 사용할 수 있다. 그렇지 않으면 항목을 계속 수집만 하고 결과를 반환하지 못한다.

이제 iter() 내장 함수로 돌아가자. 이 함수에는 지금까지 설명하지 않은 기능이 있다.

# iter() 함수 들여다보기
지금까지 봐온 것처럼 파이썬은 어떤 객체 x를 반복해야 할 때 iter(x)를 호출한다.

그러나 이 함수는 일반 함수나 콜러블 객체로부터 반복자를 생성하기 위해 두 개의 인수를 전달해서 호출할 수도 있다. 이렇게 사용하려면, 첫 번재 인수는 값을 생성하기 위해 인수 없이 반복적으로 호출되는 콜러블이어야 하며, 두 번째 인수는 구분표시로서, 콜러블에서 이 값이 반환되면 반복자가 Stopiteration 예외를 발생시키도록 만든다.

다음 예제는 1이 나올 때 까지 육면체 주사위를 굴리기 위해 iter() 함수를 사용하는 방법을 보여준다.
```
def d6():
    return randint(1, 6)


d6_iter = iter(d6, 1)
d6_iter
# <callable_iterator object at 0x0000024907CC8070>
for roll in d6_iter:
    print(roll)

"""
4
3
6
3
"""
```
여기서 iter() 함수가 callable_iterator 객체를 반환함에 주의하자. 예제 안에 있는 for 루프는 아무리 오래 실행하더라도 결코 1을 출력하지 않는다. 1이 구분 표시이기 때문이다. 다시 시작하려면 iter() 함수를 한 번 더 호출해서 반복자를 다시 만들어야 한다.

iter() 내장 함수 문서 (http://bit.ly/1HGqw70) 에서 유용한 예제를 볼 수 있다. 다음 코드는 파일에서 빈 줄을 발견하거나 파일의 끝에 도달할 때까지 한 줄씩 읽어서 처리한다.
```
with open('mydata.txt') as fp:
    for line in iter(fp.readline, ''):
        process_line(line)
```
이 장을 마치기 전에, 제너레이터를 이용해서 대용량 데이터베이스를 처리하는 실전 예제를 소개한다.
