<!-- 
- [UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part14/ex14-3/UML_class_diagram.png)
 -->
# Sentence 버전 #2: 고전적인 반복자

Sentence 클래스의 다음 버전은 디자인 패터의 청사진에 따라 고전적인 반복자 패터에 맞춰 구현한다. 나중에 리팩토링하면서 명확해지지만, 이 코드는 파이썬의 관용적인 방법은 아니다.
그렇지만 반복형 컬렉션과 반복자 객체 간의 관계를 명확히 정의하는 데 도움이 된다.

아래예제를 보면 Sentence 클래스가 반보형이다. __iter__() 특별 메서드를 구현하고 있고, 이 메서드가 SentenceIterator를 반환하기 때문이다. 이 방식이 원래 디자인 패턴에서 설명하고 있는 반복자 디자인 패턴이다.

여기서는 반복형과 반복자의 차이 및 이 둘이 어떻게 연과되는지 명확히 보여주기 위해 다음과 같이 구현한다.

- [setence_iter.py](https://github.com/hyeonDD/fluent_python/blob/master/Part14/ex14-3/setence_iter.py)
1. 앞에서 구현한 Sentence 클래스에  __iter__() 메서드만 추가했다. 여기서는 __getitem__() 메서드가 정의되어 있지 않다. __iter__()를 구현함으로써 반복형이 된다는 것을 명확히 보여주기 위해서다.
2. __iter__()가 반복자 객체를 생성해서 반환함으로써 반복형 프로토콜을 완전히 구현한다.
3. SentenceIterator는 단어 리스트에 대한 참조를 담고 있다.
4. 다음에 가져올 단어를 결정하기 위해 self.index를 사용한다.
5. self.index에 있는 단어를 가져온다.
6. self.index에 단어가 없으면 StopIteration 예외를 발생시킨다.
7. self.index를 증가시킨다.
8. 단어를 반환한다.
9. self의 __iter__() 메서드를 구현한다.

위 예제가 작동하는 데에는 사실 SentenceIterator에서 __iter__()를 구현할 필요가 없음을 주의하라. 그렇지만 올바른 구현이다. 반복자는 __next__()와 __iter__() 메서드를 모두 구현해야 하며, 둘 다 구현하면 issubclass(SentenceIterator, abc.Iterator) 테스트를 통과할 수 있다. SentenceIterator를 abc.Iterator에서 상속하면 구상 메서드인 abc.Iterator.__iter__()를 상속받는다.

정말 많은 일을 했다 (느긋한 파이썬 프로그래머치고는 많이 한 것이다.). SentenceIterator 클래스 안의 대부분의 코드가 어떻게 반복자의 내부 상태를 관리하는지 주의하라. 잠시 후 이 코드를 더 짧게 만드는 방법을 설명한다. 그러나 먼저, 간단히 구현하는 방법인 것 같지만 실제로는 잘못된 방법을 살펴보고 넘어가자.

## Sentecne를 반복자로 만들기: 좋지 않은 생각
반복형과 반복자를 만드는 데 있어서 흔히 발생하는 오류는 둘을 혼동하기 때문에 발생한다.
간단히 정리하면, 반복형은 호출될 때마다 반복자를 새로 생성하는 __iter__() 메서드를 가지고 있다. 반복자는 개별 항목을 반환하는 __next__() 메서드와 self를 반환하는 __iter__()메서드를 가지고 있다.

따라서 반복자는 반복형이지만, 반복형은 반복자가 아니다.

Sentence 클래스 안에 __iter__()외에 __next__()도 구현해서 Sentence 객체를 반복형이자 반복자로 만들고 싶을 수도 있다. 그러나 그것은 정말 잘못된 생각이다. 그리고 파이썬 코드를 엄청나게 많이 검토해본 알렉스 마르텔리에 따르면 전형적인 안티패턴이기도 하다.

디자인 패턴의 반복자 디자인 패턴 중 '응용 분야'절에서는 다음과 같이 설명하고 있다.

---

반복자 패턴은 다음과 같은 용도에 사용하라.

* 집합 객체의 내부 표현을 노출시키지 않고 내용에 접근하는 경우.
* 집합 객체의 다중 반복을 지원하는 경우
* 다양한 집합 구조체를 반복하기 위한 통일된 인터페이스를 제공하는 경우

---

'다중 반복을 지원'하려면 동일한 반복형 객체로부터 여러 독립적인 반복자를 가질 수 있어야하며, 각 반복자는 고유한 내부 상태를 유지해야 한다. 다라서 이 패턴을 제대로 구현하려면 iter(my_iterable)을 호출할 때마다 독립적인 반복자가 새로 만들어져야 한다. 그렇기 때문에 이 예제에 SentenceIterator 클래스가 필요한 것이다.
> 반복형은 자기 자신을 반복하는 반복자로 작동하면 안 된다. 즉, __iter__()를 구현하되, __next__()는 구현하면 안 된다. 한편 편의를 위해 반복자는 반복형이 되어야 한다. 이때 반복자의 __iter__()는 self를 반환햐애햐 한다.

이것으로 고전적인 반복자 패턴을 적절히 구현하는 방법에 대한 설명을 마친다. 다음 절에서는 Sentence 클래스를 좀 더 관용적인 방식으로 구현하는 방법을 설명한다.