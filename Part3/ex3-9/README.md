# dict와 set의 내부 구조
    * 파이썬 dict와 set은 얼마나 효율적인가?
    * 왜 순서가 없을까?
    * dict의 키와 set 항목에 파이썬의 모든 객체를 사용할 수 없는 이유는 무엇인가?
    * dict의 키와 set 항목의 순서가 왜 삽입 순서에 따라 달라지며, 객체 수명주기 동안 이 순서가 바뀔 수 있는 이유는 무엇일까?
    * 딕셔너리와 집합을 반복하는 동안 항목을 추가하면 왜 안될까?

    - 딕셔너리 안의 해시 테이블의 전반적인 구조 (CPython은 몇 가지 최적화 기법을 사용하고있지만 생략.)
    
    - **해시테이블**이란 희소배열(sparse arry 중간에 빈 항목을 가진 배열)이다. 해시 테이블 안에 비어있는 공간을 **버킷**이라고 한다. dict 해시 테이블에는 각 항목별로 버킷이 있고, 버킷에는 키에 대한 참조와 항목의 값에 대한 참조가 들어간다. 모든 버킷의 크기가 동일하므로 오프셋을 계산해서 각 버킷에 바로 접근할 수 있다.
    >파이썬은 버킷의 1/3 이상을 비워두려고 노력한다. 해시 테이블 항목이 많아지면 더 넓은 공간에 복사해서 버킷 공간을 확보한다. 해시 테이블 안에 항목을 넣을 때, 먼저 항목 키의 해시값을 계산한다. 해시는 hash() 내장 함수를 이용해서 계산한다.

    - 해시와 동치성
        - hash() 내장 함수는 내장 자료형은 직접 처리하고 사용자 정의 자료형의 경우 __hash__() 메서드를 호출한다. 두 객체가 동일하면 이 값의 해시값도 동일해야 한다. 그렇지 않으면 해시테이블 알고리즘이 제대로 작동하지 않는다. 예를 들어 정수 1과 실수 1의 내부 표현 형태는 다르지만, 1 == 1.0이 참이므로 hash(1) == hash(1.0)도 참이 되어야 한다.
        그리고 해시 테이블 인덱스처럼 효율성을 높이려면 해시값이 가능한 한 인덱스 공간에 골고루 퍼져야 한다. 즉, 이상적으로는 비슷하지만 동일하지 않은 객체들의 해시값은 상당히 달라야 한다.
        > 파이썬 3.3부터 str, bytes, datetime 객체의 해시에는 무작위 솔트 값이추가된다. 솔트값은 파이썬 프로세스가 실행되는 동안에는 동일하게 유지되지만, 파이썬 프로세스를 새로 실행하면 달라진다. 무작위 솔트는 DOS 공격을 피하기 위한 보안 장치로 사용된다. 자세한 설명은 __hash__() 특수 메서드에 대한 문서[__hash__문서](http://bit.ly/1FESm0m)를 참고

    - 해시테이블 알고리즘
        - my_dict[search_key]에서 값을 가져오기 위해 파이썬은 __hash__(search_key)를 호출해서 search_key의 해시값을 가져오고, 해시값의 최하위 비트를 해시 테이블 안의 버킷에 대한 오프셋으로 사용한다.
        찾아낸 버킷이 비어있으면 KeyError를 발생시키고, 그렇지 않으면 버킷에 들어있는 항목인 (found_key:found_value) 쌍을 검사해서 search_key == found_key인지 검사한다. 이 값이 일치하면 항목을 찾은 것이므로 found_value를 반환한다.
        그렇지만 search_key와 found_key가 다른 경우에는 해시충돌이 발생한 것이다. **해시 충돌**[충돌될때 비트를 다시 섞는 C함수의이름(뒤흔든다는 perturb)](http://bit.ly/1JzB8rA)은 해시 함수가 임의의 객체를 적은 수의 비트로 매핑하기 때문에 발생한다. 해시 충돌을 해결하기 위해 알고리즘은 해시의 다른 비트들을 가져와서 특정한 방식으로 조작한 후 그 결과를 이용해서 다른 버킷을 조회한다. 이때 버킷이 비어있으면 KeyError를 발생시킨다.
        그렇지 않고 키가 일치하면 항목 값을 반환하고, 키가 일치하지 않으면 다시 충돌 해결 프로세스를 반복한다.

        - 해시 테이블에 항목이 너무 많다고 파이썬이 판단하면 더 큰 공간을 가진 새로운 위치에 해시 테이블을 다시 만든다. 해시 테이블이 커지면 더 많은 해시 비트를 버킷 오프셋으로 사용되며, 더 많은 비트를 사용할수록 충동률은 낮아진다.

        - 해시 테이블을 이렇게 구현하려면 상당히 많은 작업이 필요할 것처럼 느껴지지만, dict 안에 수백만 개의 항목이 있어도 충돌 없이 검색되는 경우가 많으며, 한 번 검색할 때마다 발생하는 평균 충돌 횟수는 1에서 2 사이다. 일반적으로 운이 아주 안 좋은 키의 경우에도 몇 번의 충돌을 겪고 난 후에는 원하는 항목을 찾을 수 있다.
    
    - dict 작동 방식에 의한 영향
        dict에서 사용하는 해시 테이블의 한계와 장점.

        - **키 객체는 반드시 해시 가능해야 한다**

            1. 객체의 수명주기 동안 언제나 동일한 값을 반환하는 __hash__() 메서드를 제공해서 hash()함수를 지원한다.
            2. __eq__() 메서드를 통해 동치성을 판단할 수 있다.
            3. a == b가 참이면, hash(a) == hash(b)도 반드시 참이어야 한다.
            사용자 정의 자료형은 id()를 해시값으로 사용하고 모든 객체는 서로 동일하지 않으므로 기본적으로 해시 가능하다.
            > 클래스에서 사용자 정의 __eq__() 메서드를 구현할 때는 __hash__() 메서드도 적절히 구현해야 한다. a == b가 참이면 hash(a) == hash(b)도 언제나 참이 되어야 하기 때문이다. 그렇지 않으면 해시 테이블 알고리즘의 기본 규칙을 어기게 되어 dict나 set이 여러분이 정의한 객체를 제대로 처리할 수 없게 된다. 사용자 정의__eq__()메서드가 가변 상태에 기반하는 경우 __hash__()메서드는 반드시 unhashable type: 'MyClass'같은 형태의 메세지와 함께 TypeError를 발생시켜야 한다.
        
        - **dict의 메모리 오버헤드가 크다**
            
            - dict가 내부적으로 해시 테이블을 사용하고 있고 해시가 제대로 작동하려면 빈 공간이 충분해야 하므로, dict의 메모리 공간 효율성은 높지 않다. 예를들어 많은양의 레코드를 처리하는 경우에는, JSON 형태로 각 레코드에 하나의 dict를 할당해서 딕셔너리의 리스트를 사용하는것보다 튜플이나 명명된 튜플의 리스트에 저장하는 것이 좋다. dict를 튜플로 교체하면, 레코드마다 하나의 해시 테이블을 가져야 하는 부담과 레코드마다 필드명을 다시 저장해야 하는 부담을 제거함으로써 메모리 사용량을 줄일 수 있다.
            
            - 사용자 정의 자료형의 경우 __slots__ 클래스 속성을 이용해서 객체 속성 저장소를 dict에서 튜플로 변경할 수 있다.

            - 지금은 공간 최적화에 대해 설명하고 있다, 수백만 개의 객체를 다루고 있고 컴퓨터의 램이 수 기가바이트라면, 실제로 문제가 발생하기 전까지 이런 최적화 기법을 사용하지 않고 버틸 수 있다. 최적화는 유지보수성이 희생되는 제단이다.

        - **키 검색이 아주 빠르다**
            - 위에서 설명한 바와 같이, 내부 구조는 해시테이블을 사용하기 때문에 메모리(공간)을 포기하고 속도를 취하는 자료형이다. 

        - **키 순서는 삽입 순서에 따라 달라진다**
            - 해시 충돌이 발생하면 두 번째 키는 충돌이 발생하지 않았을 때의 정상적인 위치와 다른곳에 놓이게 된다. 따라서 
            dict([(key1, value1),(key2, value2)]) 로 생성한 딕셔너리와 dict([(key2, value2),(key1, value1)])으로 생성한 딕셔너리는 동일하지만, key1과 key2의 해시가 충돌하면 키의 순서는 달라진다.
        
        - **딕셔너리에 항목을 추가하면 기존 키의 순서가 변경될 수 있다**
            - dict에 항목을 추가할 때마다 파이썬 인터프리터는 그 딕셔너리의 해시 테이블 크기를 늘릴지 판단한다. 그리고 더 큰 해시 테이블을 새로 만들어서 기존 항목을 모두 새 테이블에 추가한다. 이 과정 동안 기존과 다르게 해시 충돌이 발생해서 새로운 해시 테이블에서의 키 순서가 달라 질 수 있다. 이 모든것은 구현 알고리즘에 따라 달라지므로, 이 현상이 언제 발생할지 정확히 예측할 수 없다. 그리고 딕셔너리 키를 반복하는 도중에 항목을 변경하는 경우에는 원하는 대로 항목을 검색하지 못하는 경우가 발생할 수 있다. 심지어 항목을 추가하기 전에 이미 있던 항목도 제대로 검색하지 못할 수 있다.
                그렇기 때문에 딕셔너리를 반복하는 동안 딕셔너리의 내용을 변경하는 것은 좋지 않은 방법이다. 딕셔너리를 검색하면서 항목을 추가해야 하는 경우에는 다음 두 단계로 수행한다.

                1. 처음부터 끝까지 딕셔너리를 검색하면서 필요한 항목은 별도의 딕셔너리에 추가한다.
                2. 별도의 딕셔너리로 원래 딕셔너리를 갱신한다.
                > 파이썬 3에서 keys(),items(),values()메서드가 반환하는 딕셔너리 뷰는, 파이썬 2에서 이 메서드들이 반환한 리스트와 달리 일종의 집합처럼 동작한다. 이 뷰는 딕셔너리의 내용을 복제하지 않고 동적으로 갱신되므로, dict의 변경사항을 즉시 반영한다.
            
    - **집합의 작동 방식 - 현실적으로 미치는 영향**
        -set, frozenset도 해시 테이블을 이용해서 구현하지만, 각 버킷이 항목으ㅔ 대한 참조만을 담고 있다는 점이 다르다(항목 자체가 dict에서의 키처럼 사용되지만, 이키를 통해 접근한 값이 없다). 사실 set이 파이썬 언어에 추가되기 전까지는 가짜 값을 가진 딕셔너리를 사용해서 키가 들어있는지 빠르게 검색하곤 했다.
            - set  요소는 모두 해시 가능한 객체여야 한다.
            - set의 메모리 오베헤드가 상당히 크다.

