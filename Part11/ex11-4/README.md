<!-- 
[UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part10/ex10-6/UML_class_diagram.png)
 -->
# 알렉스 마르텔리의 물새
파이썬의 일반적인 프로토콜형 인터페이스를 살펴본 뒤 ABC를 살펴보자. 그러나 예제와 세부사항을 파고들기 전에, ABC가 파이썬에 큰 도움이 되는 이유에 대해 알렉스 마르텔리를 초청해서 설명을 들어보자.

> 알렉스 마르텔리에게 깊은 고마움을 전한다. 그는 이 책의 테크니컬 편집자 중 한 사람이 되기 전에 이미 이 책에서 가장 많이 인용되었다. 엄청난 통찰력을 가지 그가 이 에세이를 쓰겠다고 제안했다. 그를 초빙할 수 있다니 믿기지 않을 정도로 운이 좋은것 같다, 시작해주세요, 알렉스!

---
**물새와 ABC**
알렉스 마르텔리
위키백과 (http://en.wikipedia.org/wiki/Duck_typing#History) 에 따르면 내가 '**덕 타이핑**'이라는 유행어를 퍼뜨리는 데 일조했다고 설명하고 있다. 덕 타이핑은 객체의 실제 자료형은 무시하고, 대신 객체가 용도에 맞는 메서드 이름, 시그너처, 의미를 구현하도록 보장하는 데 주안점을 둔다.

파이썬에서는 결국 자료형 검사를 위한 isinstance() 함수 사용의 회피를 의미한다. type(foo)가 bar 형인지 검사하는 훨씬 더 나쁜 방법은 말할 것도 없다. 이 방법은 가장 간단한 형태의 상속조차도 사용할 수 없게 만들어버리므로 저주받아 마땅하다!
전반적으로 **덕 타이핑**방법이 상당히 유용하게 사용되는 상황이 많지만, 그렇지 않은 상황에서는 다른 방법이 발전했다. 이와 관련된 재미있는 이야기가 있다.

지난 수십 년간 기러기라고 알려진 수름류 등을 포함해서 속과 종의 분류법은 주료 **표현학**이 주도했다. 표현학은 형태학과 동작의 유사성, 즉 **관측할 수 있는**특징에 주안점을 둔 방식이다. '덕 타이핑'과 상당히 유사하다.

그러나 평행 진화에 의해 실제로는 관련이 없지만 특이한 환경을 통해 우연히 비슷하게 진화한종들이 형태학적으로나 행위적으로 비슷한 특징을 갖게 되기도 한다. 이와 비슷한'우연한 유사성'이 프로그래밍 에서도 발생한다. 예를 들어 다음과 같은 고전적인 객체지향 예제를 보자.

```
class Artist:
    def draw(self): ... #그림 그리기

class Gunslinger:
    def draw(self): ... #총을 뽑는 행위

class Lottery:
    def draw(self): ... # 복권 추첨
```

단지 아무런 인수 없이 호출할 수 있는 draw()라는 메서드가 존재한다고 해서 x.draw()와 y.draw()로 호출할 때 x와 y 객체를 교환하거나 두 객체가 관념적으로 대등하다고 결코 보장할 수 없다. 즉, 동일한 이름의 메서드를 호출한다고 해서 의미가 비슷하다고 생각할 수 없다. 그것보다는 어느 정도 유사성을 긍정적으로 **주장**할 수 있는 프로그래머의 현명함이 필요하다!

생물학 등에서 발생한 이 문제 때문에 **분기학**이라고 알려진, 표현학을 대체하는 방법이 등장했으며, 여러 측면에서 우세를 보이고 있다. 분기학은 독자적으로 진화한 특징 대신, 공통된 조상에서 상속된 특징을 분류학적으로 선택하는 방법에 주안점을 두고 있다(최근 DNA 염기 서열 분석의 비용이 내려가고 속도가 빨라지면서 분기학을 적용할 수 있는 경우가 많아지고 있다).

예를 들어 황거위(예저는에는 거위에 가깝다고 분류되었다)와 황오리(예전에는 오리에 가깝다고 분류되었다)가 이제는 하나의 아과안에 분류된다(즉, 황오리와 황거위가 공유하는 조상이 더 가까우므로 기러기와의 다른 종류보다 서로 더 가깝다는 의미다). 게다가 DNA 분석을 해본 결과, 모습과 행동이 비슷한 흰날개 숲오리와 머스코비 오리가 실제로는 그리 가깝지 않다는 것이 증명되었다. 따라서 숲오리는 별도의 속으로 분류되어 머스코비 오리와는 전혀 다른 아과에 속하는 것으로 재분류되었다.

이게 중요한가? 상황에 따라서는 중요할 수도 있다! 예를 들어 수금류를 잡아서 요리법을 결정하기 위한 것이라면 관찰할 수 있는 특징(이 상황에서는 깃털 같은 것은 중요하지 않다)인 육질이나 맛(고전적인 표현학!)이 분기학보다 훨씬 더 관련 있을 것이다. 그렇지만 (수금류를 우리에서 키우거나 야생에서 보존하는 것에 상관없이) 병원균에 대한 취약성 등을 분석하기 위한 것이라면 DNA 친밀도가 훨씬 더 중요하다.

그러면 수금류 세상에서의 분류학적 혁명과 마찬가지로, 나는 고전적인 **덕 타이핑**을... **구스 타이핑**으로 보완하고자 한다(완전히 대체하는 것은 아니다. 상황에 따라 여전히 덕 타이핑이 적용된다)!

**구스 타이핑이라는 말은 cls가 추상베이스 클래스인 경우, 즉 cls의 메타클래스가 abc.ABCMeta인 경우에는 isinstance(obj, cls)를 써도 좋다는 것을 의미한다.

이미 collections.abc 및 파이썬 표준 라이브러리의 numbers 모듈에서 유용한 추상 클래스를 많이 찾아볼 수 있다.

구상 클래스에 비해 ABC가 가진 여러 개념적 장점 중(예를 들어 스캇 메이어의 More Effective C++)의 '33항 - 단말 노드가 아닌 클래스는 모두 추상 클래스로 만들어야 한다 (http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html)를 참조하라) 파이썬의 ABC에 실제 아주 큰 도움이 되는 register()라는 클래스 메서드가 있다. 이 메서드는 어떤 클래스가 ABC의 '가상' 서브클래스임을 '선언'할 수 있게 해준다(이렇게 선언하려면 등록할 클래스가 ABC의 메서드 이름 및 시그너처 요구사항을 만족해야 하며, 특히 메서드의 의미를 지켜야 한다. 그러나 ABC를 염두에 두고 등록할 클래스를 개발할 필요는 없다!). 이런 방식은 엄격함과 강력한 결합을 상당히 파괴하므로, 대부분의 OOP 프로그래머가 일반적으로 사용하는 상속보다 훨씬 더 많은 주의를 요구한다.

심지어 클래스를 ABC의 서브클래스로 인식시키기 위해 등록할 필요가 없는 경우도 있다!

이런 경우 ABC는 결국 몇 가지 특별 메서드로 축약된다. 다음 예제 코드를 보자.

```
class Struggle:
    def __len__(self): return 23


from collections import abc
isinstance(Struggle(), abc.Sized)
```

여기에서 볼 수 있는 것처럼 abc.Sized 클래스는 Struggle을 '일종의 서브클래스'로 인식한다. 단지 __len__()이라는 특별 메서드만 구현하면 되며, 등록할 필요도 없다. 다만__len__() 메서드는 구문(인수를 받지 않는 콜러블)과 의미 (객체의 '길이'를 나타내는 0이나 양의 정수를 반환)를 적절히 지켜야 한다. 어쨋든 구문과 의미를 적절히 지키지 않고 구현된 특별 메서드는 훨씬 더 많은 문제를 겪게 된다.

이제 설명을 정리할 때가 되었다. numbers, collections.abc, 혹은 여러분이 사용할 다른 프레임워크에 있는 ABC가 표현하는 개념을 실현하는 클래스를 구현할 때는 언제나 해당 ABC를 상속하거나 해당 ABC에 등록하라. 이 과정을 빠뜨리고 클래스를 정의한 라이브러리나 프레임워크를 사용하는 프로그램에서는 언제나 코드 시작 부분에서 여러분이 클래스를 직접 등록하길 바란다. 그러고 나서 예를 들어 인수가 '시퀀스'인지 검사해야 할 때는 다음과 같이 한다.
```
isinstance(the_arg, collections.abc.Sequence)
```
그리고 배포용 코드에서 절대로 ABC나 메타클래스를 직접 구현하지 **'말라'**. ABC를 구현하고싶은 생각이 든다면, '멋진 망치를 새로 장만한 사람에게 모든 문제가 못으로 보이는'증세라고 확실할 수 있다. 깊이를 억제하고, 직관적이고 단순한 코드를 고수한 덕분에 나중에 여러분 코드를 유지보수할 사람이 훨씬 더 행복해질 것이다. 그럼, 이만. 안녕~

---

'구스 타이핑'이라는 말을 만들어낸 것 외에도 알렉스는 필요한 메서드를 구현하는 것보다 ABC를 상속하는 것이 낫다고 강조한다. 게다가 상속은 개발자의 의도를 명확히 나타낸다. 가상 서브클래스의 등록을 통해서도 의도가 명확히 드러날 수 있다.

게다가 ABC의 서브클래스인지 테스트하기 위해 isinstacne()와 issubcalss() 함수를 사용하는 것도 개선되었다. 과거에는 이 함수들이 덕 타이핑에 해를 끼쳤지만, ABC가 등장하면서 융통성이 향상되었다. 어쨋든 상속을 통해 ABC를 구현하지 않더라도, 구현 후에 등록해서 명시적으로 자료형을 검사할 수 있기 때문이다.

그러나 ABC를 사용하더라도 isinstacne()를 너무 많이 사용하는 것은 **코드 악취**일 수 있음을 명심하라 (잘못된 객체지향 설계 증상을 보인다). 일반적으로 객체형에 따라 다른 행위를 수행할 수 있도록, 줄줄이 연결된 if/elif/elif 블록 안에서 계속 isinstance()를 검사하는 것은 **좋지 않다**. 그런 경우에는 다형성을 사용해야 한다. 즉, if/elif/elif 블록 안에서 디스패치 논리를 직접 구현하지 ㅁ라고, 인터프리터가 적절한 메서드를 호출할 수 있게 구현해야 한다.
> 그렇지만 실제로 코딩하다보면 앞에서 권장한 방법을 어기는 경우가 종종 생긴다. 일부 파이썬 API는 str인수를 하나만 받거나 str로 구성된 시퀀스 인수 하나를 받는다. 인수가 str하나만 있을 때는 쉽게 처리하기 위해 리스트 안에 str을 넣고 싶을 것이다. str도 시퀀스형이므로, str과 다른 불변형 시퀀스를 구분할 때는 isinstance(x, str)로 검사하는 게 가장 간단하다.

한편 API 요구사항을 강제로 적용해야 한다면 ABC에 대해 isinstance() 검사를 하는 것도 일반적으로 나쁘지 않다. 테크니컬 리뷰어 중 한 살마인 레나트르 레제브로에 따르면 '오바, 나를 호출하려면 자네는 이걸 구현해야 해'라고 말하는 셈이다. 이 방법은 특히 플러그인 아키텍처를 가지고 있는 시스템에서 유용하다. 그러나 프레임워크를 제외하고는 일반적으로 덕 타이핑이 자료형 검사보다 간단하고 융통성이 높다.

예를 들어 이 책에서 나온 여러 예제 클래스에서 항목들의 시퀀스를 받아 list로 처리해야 하는 경우, 필자는 자료형을 검사하지 않고 그냥 인수로부터 list를 생성했다. 이렇게 하면 어떠한 반복형도 받을 수 있으며, 인수가 반복형이 아니면 바로 에러 메세지가 나온다. 이 장 뒤에 나오는 예제에서는 이러한 코드 패턴을 다시 한 번 보여준다. 물론 시퀀스 인수가 너무 크거나 시퀀스 인수를 변경해야 하는 경우 등 시퀀스 인수를 복사하지 않아야 하는 경우에는 이 방법을 사용할 수 없다. 그런 경우에는 isinstance(x, abc.MutableSequence)로 검사하는 것이 좋다. 물론 14.1.1절 'Sequence가 반복 가능한 이유: iter() 함수'에서 설명하는 것처럼 반복자를 가져오기 위해 iter(x)를 호출하는 방법이 가장 좋다.

collections.namedtuple (https://docs.python.org/3/libraray/collections.html#collections.namedtuple) 에서 field_names 인수 처리를 흉내 내는 방법에서도 사례를 볼 수 있다. field_names는 공백이나 콤마로 구분된 식별자들의 문자열이나 식별자들의 시퀀스를 받는다. 이때 isinstance()함수를 사용하고 싶겠지만, 아래 예제처럼 덕 타이핑을 사용하는 것이 좋다.

```
try: #1
    field_names = filed_names.replace(',', ' ').split() #2
except AttributeError: #3
    pass #4
field_names = tuple(field_names) #5
```
1. 문자열이라고 가정한다.
2. 콤마를 공백으로 변환하고 그 결과를 이름들의 리스트로 분활한다.
3. 이런, field_names가 str처럼 꽥꽥거리지 않는다. replace() 메서드를 구현하지 않았거나 split()메서드를 호출할 수 없는 객체가 반환 된것이다.
4. 이제 이름들의 반복형을 가지게 되었다.
5. 반복형인지 확인하고 사본을 유지하기 위해 반복형으로부터 튜플을 생성한다.

알렉스는 자신의 글 마지막 부분에서 ABC를 우리가 직접 생성하지 말아야 함을 강조했다. ABC유행은 실용성 덕분에 인기를 얻게 된 언어에 과도한 격식을 부과함으로써 재앙을 초래하게 될것이다. 이 책을 리뷰하는 동안 알렉스는 다음과 같은 의견을 제시했다.

> **ABC는 '시퀀스'나 '정확한 숫자' 같은 일종의 프레임워크가 소개하는 상당히 광범위한 개념이나 추상성을 담기 위한 것이다. 이 책을 읽는 독자라면 ABC를 새로만들 필요가 전혀 없을 것이다. 단지 기존 ABC를 제대로 사용하는 것만으로도 잘못된 설계 위험 없이 99.9%의 헤택을 볼 것이다.**

이제 구스 타이핑을 응용해보자.
