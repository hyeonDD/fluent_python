<!-- 
[UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part10/ex10-6/UML_class_diagram.png)
 -->
# 인터페이스: 프로토콜에서 ABC까지
11장의 주제는 인터페이스다. **덕 타이핑**의 상징인 동적 프로토콜에서부터 인터페이스를 명시하고 구현이 인터페이스에 따르는지 검증하는 추상 베이스 클래스(ABC)에 이르기 까지 다양한 곳에서 인터페이스가 사용된다.

자바, C#등에 경험이 있다면 덕 타이핑이 제공하는 비공식 프로토콜이 참신하게 느껴질 것이다. 그러나 오랫동안 파이썬이나 루비를 이용해서 개발해왔다면 이런 인터페이스가 자연스럽게 느껴지고 오히려 ABC가 제공하는 공식성과 자료형 검사가 생소하게 느껴질 것이다. ABC가 파이썬에 소개될 때 파이썬은 이미 15살이었다.

먼저 파이썬 커뮤니티에서 인터페이스를 전통적으로 약간 느슨하게 이해해온 방식(부분적으로 구현된 인터페이스도 허용된다는 의미에서)을 살펴보자. 덕 타이핑의 동적 성질을 잘 보여주는 두 개의 예제를 통해 이점을 명확히 확인한다.

그리고 초대필자인 알렉스 마르텔리가 ABC에 대해 소개하고 파이썬 프로그래밍에서의 새로운 동향에 대해 안내한다. 그러고 나서 ABC에 대해 다루는데, 먼저 인터페이스를 구현할 때 ABC가 슈퍼클래스로 널리 사용되는 것을 보여준다. 그리고 구상 서브클래스가 자신이 정의한인터페이스에 부합되는지 여부를 ABC가 언제 검사하는지와, 클래스를 상속하지 않고도 클래스가 인터페이스를 구현한다고 개발자가 선언할 수 있게 해주는 등록 메커니즘의 작동 방식을 알아본다. 마지막으로, 상속하거나 명시적으로 등록하지 않고도 인터페이스에 부합하는 임의의 클래스를 자동으로 '인식'할 수 있게 ABC를 프로그래밍하는 방법을 설명한다.

여기서는 예제를 통해 설명하기 위해 ABC를 새로 구현하지만, 알렉스 마르텔리와 필자는 여러분이 완전히 새로운 ABC를 작성하는 것을 권장하지 않는다. ABC를 불필요할 정도로 탄탄하게 만들 위험이 너무 크다.
> 디스크립터나 메타클래스와 같은 ABC는 프레임워크를 만들기 위한 도구다. 그러므로 동료 프로그래머에게 부당한 제한과 불필요한 작업 부담을 지우지 않고 ABC를 작성할 수 있는 파이썬 개발자는 극소수에 불과하다.

먼저 파이썬스러운 관점에서 인터페이스를 살펴보자.

# 요약
이 장의 목표는 프로토콜이라고 불리는 비공식 인터페이스의 상당히 동적인 성질에서 출발해서 ABC의 정적 인터페이스 선언을 둘러보고, __subclasshook__()으로 가상 서브클래스와 동적 서브클래스를 탐지하는 ABC의 동적인 측면으로 마치는 것이었다.

먼저 파이썬 커뮤니티에서 인터페이스에 대해 전통적으로 가지고 있던 생각을 돌아보았다. 거의 대부분의 파이썬 역사에서 우리는 인터페이스를 신경 써왔지만, 인터페이스는 스몰토크의 프로토콜처럼 비공식적이었으며, 공식 문서조차도 'foo 프로토콜', 'foo 인터페이스', 'foo와 같은 객체'등의 용어를 혼용해서 사용했다. 프로토콜 유형의 인터페이스는 상속과는 아무런 관련이 없다. 각 클래스가 독립적으로 프로토콜을 구현하기 때문이다. 덕 타이핑을 깨달았을 때 본 그것이 바로 인터페이스다.

```
class Foo:
    def __getitem__(self, pos):
        return range(0, 30, 10)[pos]


f = Foo()
f[1]

for i in f: print(i)

20 in f
15 in f
```
위에서는 파이썬이 시퀀스 프로토콜을 얼마나 깊숙이 지원하는지 살펴보았다. 클래스가 단지 __getitem__()만 구현하더라도 파이썬은 그 객체를 반복할 수 있고, in 연산자도 제대로 작동한다. 그러고 나서 1장에서 보았던 FrenchDeck 예제로 돌아가서 메서드를 동적으로 추가함으로써 카드 섞는 연산을 지원했다. 이런 방식을 멍키 패칭이라고 하며 프로토콜의 동적 성질을 잘 보여준다. 또 한 번 부분적으로 구현된 프로토콜도 얼마나 유용해질 수 있는지 확인했다. 가변 시퀀스 프로토콜의 __setitem__() 메서드만 추가해도 표준 라이브러리에서 제공하는 random.shuffle()을 사용할 수 있게 되었다. 기존 프로토콜을 이해하면 파이썬 표준 라이브러리가 제공하는 풍부한 기능의 대부분을 사용할 수 있다.

그러고 나서 알렉스 마르텔리가 '구스 타이핑'이라는 용어를 소개하면서 새로운 파이썬 프로그래밍을 설명했다. 구스 타이핑 덕분에 ABC를 사용해서 인터페이스를 명시할 수 있고, 강력하고 정적인 상속 관계를 정의하지 않고도 클래스가 ABC를 상속하거나 ABC에 등록해서 어떤 인터페이스를 구현한다고 주장할 수 있다.

FrenchDeck2 예제는 ABC의 주요 장단점을 명확히 보여준다. abc.MutableSequence를 상속함으로써 우리에게 필요 없는 insert()와 __delitem__() 메서드를 구현해야 한다. 한편 파이썬 초보자도 FrenchDeck2 클래스가 가변 시퀀스라는 것을 알 수 있다. 게다가 abc.MutableSequence로 부터 바로 사용할 수 있는 메서드 11개를 물려 받는다(그중 5개는 abc.Sequence가 제공한다).

![sequence사진](https://github.com/hyeonDD/fluent_python/blob/master/Part11/ex11-1~3/sequence.png)

위 그림에서 collections.abc에서 제공하는 기존 ABC들을 쭉 둘러본 후, 처음부터 ABC클래스 하나를 작성했다. 금주의 파이썬 모듈 (http:/pymotw.com/)의 제작자 더그헬먼은 ABC를 만드는 동기에 대해 다음과 같이 이야기한다.
    **추상 베이스 클래스를 정의함으로써 일련의 서브클래스에 대해 공통된 API를 규정할 수 있다. 이 기능은 특히 애프리케이션 소스 코드에 익수지 않은 사람들이 플러그인 확장을 제공하려 할때 유용하다**
Tombola ABC를 이용하면서 우리는 구상 서브클래스 세 개를 생성했다. 두 개는 Tombola를 상속하고, 나머지 하나는 Tombola에 등록한 가상 서브클래스다. 이들 클래스 모두 동일한 일련의 테스트를 통과했다.

또한 여러 내장 자료형이 collections.abc 모듈의 ABC에 어떻게 등록되어 있는지 설명했다.
따라서 memoryview가 abc.Sequence를 상속하지 않더라도 isinstacne(memoryview, abc.Sequence) 코드가 True를 반환한다. 그리고 마지막으로 __subclasshook__() 마술을 간단히 살펴봤다. __subclasshook__() 메서드는 등록되지 않은 클래스도 간단하든 복잡하든 어떤 테스트를 통과하면 ABC가 서브클래스로 인식할 수 있게 해준다. 표준 라이브러리에 있는 에제는 단지 메서드명을 확인해서 테스트한다.

이제 정리해보자. 사용자가 확장할 수 있는 프레임워크를 만들지 않는 한 우리가 직접 ABC를 만들지 않아야 한다는 알렉스 마르텔리의 충고를 다시 한 번 얘기하고 싶다. 일상적으로 우리는 프레임워크를 만들기보다는 기존 ABC를 상속하거나 ABC에 등록하는 일을 주로 한다. 상속이나 등록보다는 드물지만 ABC를 이용해서 isinstacne()로 검사를 하기도 한다. 그리고 ABC 클래스를 처음부터 만드는 일은 이보다도 훨씬 더 드물다.

15년 동안 파이썬으로 개발해오면서 필자가 처음으로 만든 추상 베이스 클래스는 Pingo 프로젝트에 들어가는 Board 클래스 (https://github.com/garoa/pingo/blob/master/pingo/board.py) 였다. 이는 그리 교훈적인 예는 아니다. 여러 단일 기판 컴퓨터와 컨트롤러를 지원하는 드라이버가 Board의 서브클래스이므로, 드라이버는 동일한 인터페이스를 공유한다. 사실 추상클래스로 설계하고 구현했지만, pingo.Board 클래스는 abc.ABC를 상속하지 않는다. 궁극적으로 Board 클래스를 ABC로 명시하려 했지만, 프로젝트에서는 더 중요한 일이 많았다.