<!-- 
- [UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part17/ex17-2~3/UML_class_diagram.png)
 -->
# 블로킹 I/O와 GIL
CPython 인터프리터는 내부적으로 스레드 안전하지 않으므로, 전역 인터프리터 락(GIL)을 가지고 있다. GIL은 한 번에 한 스레드만 파이썬 바이트코드를 실행하도록 제한한다. 그렇기 때문에 단일 파이썬 프로세스가 동시에 다중 CPU 코어를 사용할 수 없다.

파이썬 코드를 작성할 때 우리는 GIL을 제어할 수 없지만, 내장 함수나 C로 작성된 확장은 시간이 오래 걸리는 작업을 실행할 때 GIL을 해제할 수 있다. 사실 C로 작성된 파이썬 라이브러리는 GIL을 관리하고, 자신의 OS 스레드를 생성해서 가용한 CPU 코드를 모두 사용할 수 있다. 하지만 라이브러리 코드가 상당히 복잡해지므로, 대부분의 라이브러리 제작자는 이런 방식으로 구현하지 않는다.

그런데 블로킹 입추력을 실행하는 모든 표준 라이브러리 함수는 OS에서 결과를 기다리는 동안 GIL을 해제한다. 즉, 입출력 위주의 작업을 실행하는 파이썬 프로그램은 파이썬으로 구현하더라도 스레드를 이용함으로써 이득을 볼 수 있다는 것이다. 파이썬 스레드가 네트워크로부터의 응답을 기다리는 동안, 블로킹된 입출력 함수가 GIL을 해제함으로써 다른 스레드가 실행될 수 있다.

이런 이유로 데이비드 비즐리는 '파이썬 스레드는 아주 능숙하게 게으름을 피운다'고 한다.
> 파이썬 표준 라이브러리의 모든 블로킹 입출력 함수는 GIL을 해제해서 다른 스레드가 실행할 수 있게 해준다. time.sleep() 함수도 GIL을 해제한다. 따라서 GIL을 사용하고 있더라도 파이썬 스레드는 입출력 위주의 애플리케이션에서는 엄청난 효용성이 있다.

이제 concurrent.futures를 사용해서 계산 위주의 작업에서 GIL을 우회하는 간단한 방법을 살펴보자.

# concurrent.futures로 프로세스 실행하기
concurrent.futures 문서 페이지 (https://docs.python.org/3/libraray/concurrent.futures.html) 의 부제는 '병렬 작업의 실행'이다. 이 패키지는 ProcessPoolExecutor클래스를 사용해서 작업을 여러 파이썬 프로세스에 분산시켜 진정한 병렬 컴퓨팅을 가능하게 한다. ProcessPoolExecutor는 GIL을 우회하므로 계산 위주의 작업을 수행해야 하는 경우 가용한 CPU를 모두 사용한다.

ProcessPoolExecutor와 ThreadPoolExecutor는 모두 범용 Executor 인터페이스를 구현하므로, concurrent.futures를 사용하는 경우에는 스레드 기반의 프로그램을 프로세스 기반의 프로그램으로 쉽게 변환할 수 있다. 국기를 내려받는 프로그램처럼 입출력 위주의 작업장에서는 ProcessPoolExecutor를 사용해도 도움이 안된다. flags_threadpool.py의 다음 코드를 변경하면 쉽게 이 사실을 알 수 있다.
```
def download_many(cc_list):
    workers = min(MAX_WORKERS, len(cc_list))
    with futures.ThreadPoolExecutor(workers) as executor:
```
위 코드를 다음과 같이 변경해서 테스트해보라.
```
def download_many(cc_list):
    with futures.ProcessPoolexecutor() as executor:
```
간단히 사용할 때는 이 두 구상 Executor 클래스 중 ThreadPoolExecutor만 __init__() 메서드에 max_workers 인수를 통해 풀에 스레드 수를 지정해야 하는 차이점만 보인다. 이 인수는 processPoolExecutor에서는 선택적인 인수로서 os.cpu_count()가 반환하는 값을 사용하므로 대부분의 경우 직접 설정하지 않는다. 계산 위주의 작업을 처리하는 경우 CPU보다 많은 수의 작업자를 요청하는 것은 의미가 없으므로, 별도로 지정하지 않는 것이 타당하다. 그러나 입출력 위주의 연산을 수행하는 경우에는 ThreadPoolExecutor에 수십 내지 수천 개의 스레드를 사용할 수 있다. 최적의 스레드 수는 처리할 작업의 특성과 가용한 메모리에 따라 다르므로, 신중히 테스트해서 최적의 스레드 수를 찾아내야 한다.

몇번 테스트해보니 ProcessPoolExecutor를 이용해서 20개의 국기 이미지를 내려받는 평균시간이 1.8초 정도로 느려졌다. 원래의 ThreadPoolExecutor 버전의 경우 1.4초 정도였다. 필자가 테스트한 컴퓨터의 CPU 코어가 네 개이므로 동시에 내려받는 작업 수가 스레드 버전에서 사용한 20개의 작업자보다 제한되어 있기 때문인 것 같다.

ProcessPoolExecutor는 계산 위주의 작업에서 진가를 발휘한다. 다음과 같은 두 가지 계산위주의 프로그램을 이용해서 성능 테스트를 해보았다.

---

**arcfour_futures.py**
순수하게 파이썬으로 구현된 RC4 알고리즘을 이용해서 149KB에서 384KB 정도 되는 바이트 배열 10개를 암호화하고 복호화한다(예제 A-7)
**sha_futures.py**
OpenSSL 라이브러리를 사용하는 표준 라이브러리 패키지 hashlib를 이용해서 1MB 바이트 배열 10개에 대한 SHA-256 해시를 계산한다(A-9)

---

이 두 스크립트는 최종 결과를 화면에 출력하는 것 외에 아무런 입출력 연산을 수행하지 않는다. 데이터를 모두 메모리에 생성하고 처리하므로, 입출력에 의해 실행을 간섭받지 않는다.

아래 표는 RC4 예제를 64번, SHA 예제를 48번 실행한 평균 시간이다. 실제로 생성한 작업자 프로세스 수도 포함했다.

| 작업자 수 | RC4 시간 | RC4 가속률 | SHA 시간 | SHA 가속률 |
| :--- | :--- | :--- | :--- | :--- |
| 1 | 11.48초 | 1.00X | 22.66초 | 1.00x |
| 2 | 8.65초 | 1.33X | 14.90초 | 1.52x |
| 3 | 6.04초 | 1.90X | 11.91초 | 1.90x |
| 4 | 5.58초 | 2.06X | 10.89초 | 2.08x |

정리해보면, CPU 코어가 4개인 컴퓨터에서 ProcessPoolExecutor로 4개의 작업자 프로세스를 생성해서 암호 알고리즘을 병렬로 처리하면 2배 정도의 성능 향상을 기대할 수 있다.

순수 파이썬으로 구현된 RC4의 예제의 경우 PyPy 인터프리터로 4개의 작업자 프로세스를 사용하면 CPython으로 3개의 작업자 프로세스를 사용하는 경우보다 3.8배 빨라진다. 결국 위 표의 CPython 인터프리터로 작업자 스레드를 하나만 생성한 경우보다 7.8배 빨라진 것이다.
> 파이썬으로 계산 위주의 작업을 수행한다면 PyPy (https://pypy.org/) 를 사용하는 것이 좋다. arcfour_futures.py의 경우 사용한 작업자의 수에 따라 3.8에서 5.1배빨라진다. PyPy 2.4.0은 파이썬 3.2.5와 호환되므로 표준 라이브러리의 concurrent.futures 패키지도 가지고 있다.

이제 세 개의 작업자를 이용해서 타임스탬프가 붙은 메시지를 출력하는 콜러블 5개를 실행하는 예제 프로그램을 이용해서 스레드 풀의 동작을 살펴보자.

