# 바이트에 대한 기본 지식

- 새로 도입된 이진 시퀀스형은 파이썬 2의 str과 여러모로 다르다. 우선 이진 시퀀스를 위해 사용되는 내장 자료형은 bytes와 bytearray, 두 가지가 있다는 점에 주의한다. bytes 형은 파이썬 3에서 소개된 불변형이고, bytearray는 파이썬 2.6에 추가된 가변형이다(파이썬 2.6에서도 bytes 형을 소개했지만 단지 str형의 별명이었을 뿐, 파이썬 3의 bytes 형과는 작동 방식이 달랐다.)


- bytes와 bytearray에 들어 있는 각 항목은 0에서 255 사이의 정수로, 파이썬 2의 str에 들어있는 문자 하나로 구성된 문자열과는 다르다. 그러나 이진 시퀀스를 슬라이싱하면 언제나 동일한 자료형의 이진 시퀀스가 만들어지며, 슬라이스 길이가 1일 때도 마찬가지다.[bytes, bytearr 예제](https://github.com/hyeonDD/fluent_python/blob/master/Part3/ex4-2~4~4/bytes.py "소스코드")
> my_bytes[0]은 int 형을 반환하지만, my_bytes[:1]은 길이가 1인 bytes 객체를 반환한다는 사실은 그리 놀랍지 않다. s[0] == s[:1]이 되는 시퀀스형은 str이 유일하다. 실용적이기는 하지만 str의 이런 작동 방식은 예외적인 것이다. 그 외 모든 시퀀스의 경우, s[i]는 항목 하나를, s[i:i+1]은 안에 s[i]항목을 가진 동일한 자료형의 시퀀스를 반환한다.

- 이진 시퀀스가 실제로 정수형의 시퀀스이긴 하지만, 리터럴 표기법을 보면 실제로는 아스키 텍스트가 들어가는 경우가 많다는 것을 알 수 있다. 따라서 각 바이트 값에 따라 다음과 같이 세가지 형태로 출력된다.
    * 화면에 출력 가능한 아스키 문자(공백에서 물결포(~)까지)는 문자 그대로 출력한다.
    
    * 탭, 개행 문자, 캐리지리턴, 백슬래시(\)는 이스케이프 시퀀스(\t, \n, \r, \\)로 출력한다.
    
    * 그 외의 값은 널 바이트를 나타내는 \x00처럼 16진수 이스케이프 시퀀스로 출력한다.

- 출력 가능한것은 문자 그대로 출력해주기 때문에 [bytes, bytearr 예제](https://github.com/hyeonDD/fluent_python/blob/master/Part3/ex4-2~4~4/bytes.py "소스코드")에서 b'cafe\xed\x95\x9c'와 같이 cafe까지는 출력 가능한 아스키 범위에 있기에 그대로 출력 후 '한'이라는 글자는 기계 메모리 덤프 형태로 출력됨.

- bytes와 bytearray는 포매팅하는 format()과 format_map() 메서드를 제외하고는 str이 제공하는 메서드를 모드 지원하며, casefold(), isdecimal(), isdentifier(), isnumeric(), isprintable(), encode()등 유니코드 데이터에 관련된 메서드를 지원한다. 따라서 endswith(), replace(), strip(), translate(),upper()등의 메서드를 지원한다. 따라서 endswith(), replace(), strip(), translate(), upper() 등의 메서드를 str이 아닌 bytes 인수에도 적용할 수 있따. 게다가 str 대신 이진 시퀀스로 정규 표현식을 컴파일하면 re 모듈에서 제공하는 정규 표현식 함수를 이진 시퀀스에도 적용할 수 있다. 파이썬 3.0부터 3.4 까지는 이진 시퀀스에 퍼센트(%) 연산자를 사용할 수 없지만, 'PEP 461 - bytes와 bytearray에 % 포맷 추가' 제안서(https://www.python.org/dev/peps/pep-0461/)에 따라 파이썬 3.5에서는 퍼센트 연산자도 지원한다.
이진 시퀀스는 fromhex()라는 str에 없는 클래스 메서드도 제공하는데, 이 메서드를 이용하면 공백으로 구분된 16진수 쌍을 파싱해서 이진 시퀀스를 만들 수 있다.[str to 이진시퀀스](https://github.com/hyeonDD/fluent_python/blob/master/Part3/ex4-2~4/str_to_2seq.py "소스코드")
    - 생성에 다음과 같은 인수를 이용해서 bytes나 bytearray 객체를 생성할 수 있다.
        * str과 encoding 키워드 인수

        * 0에서 255사이의 값을 제공하는 반복 가능형

        * 하나의 정수 인수. 인수로 받은 정수 개수만큼의 널 바이트로 초기화된 이진 시퀀스를 생성한다(이 생성자 시그너처는 파이썬 3.5에서 사용 중단 안내되었으며, 파이썬3.6에서 제거되었다.)

        * bytes, bytearray, memoryview, array.array 등 버퍼 프로토콜을 구현하는 객체. 이 메서드를 사용하면 원본 객체의 바이트를 복사해서 바이트 시퀀스를 새로 생성한다.
    - 버퍼와 같은 객체로부터 bytes, bytearray 객체를 생성하면 언제나 바이트를 복사한다. 이와 반대로 memoryview는 이진 데이터 구조체 간에 메모리를 공유할 수 있게 해준다. 이진 시퀀스에서 구조화된 정보를 추출하려면 struct 모듈을 사용한다. 다음 절에서 bytes와 memoryview에 struct 모듈 사용하는 방법을 설명한다.

# **구조체와 메모리 뷰**

- struct 모듈은 패킹된 바이트를 다양한 형의 필드로 구성된 튜플로 분석하고, 이와 반대로 튜플을 패킹된 바이트로 변환하는 함수를 제공한다. struct는 bytes, bytearray, memoryview객체와 함께 사용된다.

- memoryview 클래스로 바이트 시퀀스를 생성하거나 저장할 수는 없지만, 바이트를 복사하지 않고 다른 이진 시퀀스, 패킹된 배열, 혹은 파이썬 이미징 라이브러리(PIL) 이미지등 버퍼 데이터의 슬라이스에 공유 메모리 방식으로 접근할 수 있게 해준다.
> PIL 포크(fork)중 Pillow (https://pillow.readthedocx.org/en/latest/) 가 가장 활발히 개발되고 있다.

- [memoryview와 struct 예제](https://github.com/hyeonDD/fluent_python/blob/master/Part3/ex4-2~4/memoryview_struct.py "소스코드")
memoryview를 슬라이싱하면 바이트를 복사하지 않고 새로운 memoryview 객체를 반환함에 주의하라(이 책의 테크니컬 리뷰어 중 한 명인 레오나르도 로챌은 mmap 모듈을 사용해서 이미지를 메모리 맵 파일로 열면 훨씬 더 적은 바이트가 복사됨을 알려주었다.) 이 책에서는 **mmap**에 대해 설명하지 않지만, 이진 파일을 읽고 변경하는 작업을 자주 수행하게 된다면 mmap을 공부하자. 'mmap - 메모리 맵 파일 지원(https://docx.python.org/3/library/mmap.html)을 참조해라'. 이 책에서는 memoryview나 struct 모듈에 대해 깊이 파고들지는 않지만, 이진 데이터를 사용한다면 '내장 자료형 >> 메모리 뷰(http://bit.ly/1Vm7Znl)와 'struct - bytes를 패킹된 이진 데이터로 해석하기(http://bit.ly/1Vm7YjA)를 공부해둘 필요가 있다).

# 기본 인코더/디코더
- 이진 시퀀스가 어떻게 문자열로/에서 변환되는지 알아보자.

- 텍스트를 바이트로 혹은 바이트를 텍스트로 변환하기 위해 파이썬 배포본에는 100여 개의 코덱(인코더/디코디)이 포함되어 있다. 각 코덱은 utf_8와 같은 이름을 갖고 있는데, utf8. utf-8, U8 등으로 불리기도 한다. 코덱은 open(), str.encode(), bytes.decode()등의 함수를 호출할 때 encoding 인수에 전달해서 사용할 수 있다. [예제](https://github.com/hyeonDD/fluent_python/blob/master/Part3/ex4-2~4/default_encode.py "소스코드")


# 인코딩/디코딩 문제 이해하기
- UnicodeError라는 범용 예외가 있지만, 거의 항상 UnicodeEncodeError(str을 이진 시퀀스로 변환할 때)나 UnicodeDecodeError(이진 시퀀스를 str로 읽어 들일 때) 같은 구체적인 예외가 발생한다. 파이썬 모듈을 로딩할 때 소스 코드가 예기치 않은 방식으로 인코딩되어 있으면 SyntaxError가 발생하기도 한다.
> 유니코드 에러가 발생할 때는 먼저 예외의 정확한 유형을 알아내야 한다. 문제를 해결하려면 먼저 인코딩 에러가 UnicodeEncodeError인지, UnicodeDecodeError인지, 아니면 SyntaxError등 다른 에러인지 구체적인 유형을 알아내야 한다.

# UnicodeEncodeError 처리하기
- 대부분의 비UTF 코덱은 유니코드 문자의 일부만 처리할 수 있다. 텍스트를 바이트로 변환할때 문자가 대상 인코딩에 정의되어 있지 않으면, 인코딩 메서드나 함수의 errors 인수에 별도의 처리기를 지정하지 않는 한 UnicodeEncodeError가 발생한다. 에러 처리기를 사용하는 방법은 

# UnicodeDecodeError 처리하기
- 모든 바이트가 정당한 아스키 문자가 될 수 없으며, 모든 바이트 시퀀스가 정당한 UTF-8이나 UTF-16문자가 되는 것은 아니다. 따라서 이진 시퀀스를 텍스트로 변환할 때 정당한 문자로 변환할 수 없으면 UnicodeDecodeError가 발생한다.

- 하지만 cp1252, iso8859_1, koi8_r 등 많은 레거시 8비트 코덱은 무작위 비트 배열에 대해서도 에러를 발생시키지 않고 바이트 스트림으로 디코딩할 수 있다. 따라서 프로그램이 잘못된 8비트 코덱을 사용하면 쓰레기 문자를 조용히 디코딩하게 된다.
> 왜곡된 문자를 그렘린(gremlin) 혹인 문자깨짐 이라고 한다.

- [잘못된 코덱의 예제](https://github.com/hyeonDD/fluent_python/blob/master/Part3/ex4-2~4/wrong_codec.py "소스코드")

# 바이트 시퀀스의 인코딩 방식을 알아내는 방법

- 바이트 시퀀스의 인코딩 방식을 어떻게 알아낼 수 있을까? 간단히 말하면, 할 수 없다. 반드시 별도로 인코딩 정보를 가져와야 한다.

- HTTP나 XML 같은 통신 프로토콜이나 파일 포맷은 내용이 어떻게 인코딩되어 있는지 명시하는 헤더를 가지고 있다. 바이트 스트림에 127이 넘는 값이 들어 있다면 아스키로 인코딩되어 있지 않음을 확신할 수 있고, UTF-8과 UTF-16 인코딩에서도 생성할 수 있는 바이트 시퀀스가 한정되어 있다. 그렇지만 어떤 비트 패턴이 존재하지 않는다고 해서 이진 파일이 아스키로 인코딩되어 있는지 아니면 UTF-8로 인코딩되어 있는지 100% 확신할 수는 없다.

- 하지만 일단 바이트 스트림이 **자연어(평문텍스트)**라고 간주되면, 자연어에도 어떠한 규칙과 제한이 있다는 점을 고려하고 경험과 통계를 이용해서 인코딩 방식을 추정할 수 있다. 예를들어 b'\x00' 바이트가 많이 나타난다면, 이 파일은 8비트가 아니라 16이나 32비트로 인코딩 되어 있을 가능성이 크다. 일번적으로 자연어 중간에는 널 문자가 들어가지 않기 때문이다. 그리고 b'\x20\x00' 바이트 시퀀스가 자주 나타난다면, 이 문자는 잘 사용되지 않는 U+2000(ENQUAD 문자)이라기 보다는 UTF-16LE 인코딩에서의 공백 문자(U+0020)일 가능성이 크다.
다양한 문자 인코딩을 탐지하는 Chardet[설명링크](https://pypi.python.org/pypi/chardet)는 이런 방법을 이용해서 30가지 인코딩 방식을 알아낸다. Chardet은 프로그램에서 사용할 수 있는 파이썬 라이브러리일 뿐만 아니라 chardetect라는 명령행 유틸리티도 포함하고 있다.

# BOM: 유용한 깨진 문자
- [예제](https://github.com/hyeonDD/fluent_python/blob/master/Part3/ex4-2~4/default_encode.py "소스코드") 에서 UTF-16으로 인코딩된 텍스트 앞에 여분의 바이트가 있는 것을 보았다. 해당 부분만 옮겨오면 아래와 같다.

***
\>>> u16 = 'El NiÑo'.encode('utf_16')

\>>> u16
b'\xff\xfeE\x00l\x00 \x00N\x00i\x00\xd1\x00o\x00'
***
b '\xff\xfe' 문자가 앞에 나온것을 볼 수 있다. 이 문자가 바로 바이트 순서 표시(**BOM**)로, 인코딩한 인텔 CPU의 '리틀엔디언'바이트 순서를 나타낸다.

리틀 엔디언 컴퓨터에서는 코드 포인트의 최하위 바이트가 먼저 나온다. 코드 포인트가 U+0045(십진수 69)인 'E' 문자는 다음과 같이 바이트 오프셋 2와 3에 69와 0으로 인코딩되었다.

***
\>>> list(u16)
*** 
빅 엔디언 컴퓨터에서는 인코딩 순서가 반대로 되어 'E'는 0과 69로 인코딩된다.

혼란을 방지하기 위해 UTF-16 인코등인 ZERO WIDTH NO-BREAK SPACE(U+FEFF)라는 특수문자를 인코딩된 텍스트 앞에 붙이는데, 이 문자는 화면에 출력되지 않는다. 리틀엔디언 컴퓨터에서 이 문자는 b'\xff\xe' (십진수 255, 254)로 인코딩된다. UTF-16에 U+FFFE에 해당하는 문자는 없으므로 바이트 시퀀스 b'\xff\xfe'는 리틀엔디언으로 인코딩된 ZERO WIDTH NO-BREAK SPACE 문자를 나타내며, 코덱은 어떤 바이트 순서를 사용해야 할지 알 수 있다.

UTF-16에는 리틀엔디언을 명시하는 UTF-16LE와 빅엔디언을 명시하는 UTF-16BE 변형이 있다.

***
\>>> list(u16le)
[69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 209, 0, 111, 0]

\>>> u16be = 'El NiÑo'.encode('utf_16be') 

\>>> list(u16be)
[0, 69, 0, 108, 0, 32, 0, 78, 0, 105, 0, 209, 0, 111]
***

존재하지 않는 경우 BOM은 UTF-16 코덱에 의해 걸러지므로, 텍스트로 변환한 후에는 앞에 추가된 ZERO WIDTH NO-BREAK SPACE 문자 없이 파일의 실제 내용만 가져온다.
표준에 의하면 UTF-16 파일에 BOM이 없다면 이 파일은 UTF-16BE(빅엔디언)로 인코딩되어 있다고 가정해야 한다.
그렇지만 인텔x86 아키텍처가 리틀엔디언이므로, 실제로는 BOM이 없지만 UTF-16LE(리틀엔디언)로 인코딩된 파일도 많다.

엔디언 문제는 한 바이트 이상을 워드로 사용하는 UTF-16과 UTF-32에만 영향을 준다.
UTF-8은 컴퓨터의 엔디언 특성에 상관없이 동일한 바이트 시퀀스를 생성하므로 BOM이 필요 없다는 장점이 있다.
그렇지만 윈도우 애플리케이션(특히 노트패드)은 UTF-8로 인코딩하면서 파일에 BOM을 붙인다.
마이크로소프트 엑셀의 경우 UTF-8 파일을 탐지하기 위해 BOM에 의존하며, BOM이 없는 경우에는 바이트 스트림이 윈도우 코드페이지로 인코딩되어 있다고 가정한다.
U+FEFF 문자를 UTF-8로 인코딩하면 세 바이트 길이의 b'\xef\xbb\xbf'가 된다.
따라서 이 세 바이트로 시작하는 파일은 BOM 이 추가된 UTF-8 파일일 가능성이 높다.
그러나 파이썬 파일이 b'\xef\xbb\xbf' 시퀀스로 시작되었다 하더라도 자동으로 파일이 UTF-8로 인코딩 되어 있다고 가정하지 않는다.



    
