# 디자인 패턴 : 명령
<!-- 
![UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part6/ex6-2/UML_class_diagram.png)
 -->
함수를 인수로 전달하는 기법을 사용하면 명령 디자인 패턴도 구현을 단순하게 만들 수 있다.
아래 그림은 명령 패턴에 사용되는 클래스들을 나열한 것이다.
![명령 디자인패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part6/ex6-2/UML_command_diagram.png)
> 명령 디자인 패턴으로 구현한 메뉴 방식 텍스트 편집기에 대한 UML 클래스 다이어그램. 각각의 명령은 서로 다른 수신자(행동을 구현하는 객체)를 가질 수 있다. PasteCommand의 경우 Document가 수신자며, OpenCommand의 경우 Application이 수신자다.

명령 패턴의 목적은 연산을 실행하는 객체(호출자)와 연산을 구현하는 객체(수신자)를 분리하는 것이다. '디자인 패턴'예에서는 그래픽 애플리케이션의 메뉴 항목이 호출자며, 편집되고 있는 문서나 애플리케이션 자신이 수신자다.

기본 개념은 명령 객체를 수신자와 호출자 사이에 놓고, 명령은 excute()라는 단 하나의 메서드로 인터페이스를 구현한다. execute()는 원하는 연산을 수행하기 위해 수신자가 가지고 있는 메서드를 호출한다. 이런 방식을 사용하면, 호출자는 수신자의 인터페이스를 알 필요가 없으며, 명령의 서브클래스를 통해 서로 다른 수신자를 추가할 수 있다. 호출자는 구체적인 명령으로 설정되며, 연산을 실행하기 위해 excute()메서드를 호출한다. 그림에서 MacroCommand 명령 객체는 일련의 명령을 저장할 수 있다. 이때 excute() 메서드는 저장된 각 명령의 excute() 메서드를 호출한다.

'디자인 패턴'에서는 '명령은 콜백에 대한 객체지향식 대체물'이라고 설명하고 있다. 그렇지만 콜백을 객체지향식 대체물로 바꿀 필요가 있을까?때로는 그럴 수 있지만, 늘 그런것은 아니다.

호출자에 Command 객체 대신 간단히 함수를 바로 지정할 수 있다. command.excute()를 호출하는 대신, 호출자는 단지 command()를 호출하면 된다. MacroCommand는 __call__()메서드를 가진 클래스로 구현할 수 있다. MacroCommand의 객체는 콜러블이 되며, 각 객체는 아래 예제에서 보는 것처럼 향후에 함수들의 리스트를 가진다.

```
class MacroCommand:
    """명령 리스트를 실행하는 명령"""

    def __init__(self, commands):
        self.commands = list(commands)
    
    def __call__(self):
    for command in self.commands:
        command()
```
1. commands 인수로부터 리스트를 만들면 명령들이 반복 가능한 객체임이 보장되며, 각각의 MacroCommand객체 안에 명령에 대한 참조를 복사하게 된다.
2. MacroCommand 객체가 호출되면 self.commands에 들어 있는 명령이 순서대로 호출된다.

실행 최소 지원 등 고급 기능의 명령 패턴을 구현하려면 단순한 콜백 함수로는 어려울 수도 있지만, 이런 경우에도 파이썬에서는 다음과 같은 두가지 대안을 제시한다.
* 위 소스코드의 MacroCommand와 같은 콜러블 객체는 필요한 상태를 보관함으로써 __call__() 메서드 이외의 메서드도 제공할 수 있다.
* 함수가 호출된 후의 상태를 내부에 보관하기 위해 클로저를 사용할 수 있다.

지금까지 명령 패턴을 일급 함수로 대체하는 방법에 대해 생각해보았다. 상위 수준에서 보면이 접근법은 전략 패턴에 사용했던 방법과 비슷하다. 즉, 단일 메서드 인터페이스를 구현하는 클래스의 객체를 콜러블로 대체하는 것이다. 모든 파이썬 콜러블이 __call__()이라는 단일 메서드 인터페이스를 구현하므로, 이런 대안이 가능하다.