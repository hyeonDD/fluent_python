# 사례: 전략 패턴의 리팩토링
전략 패턴은 파이썬에서 함수를 일급 객체로 사용하면 더욱 간단해질 수 있는 디자인 패턴의 대표적인 사례다. 다음 절에서는 '디자인 패턴'에서 설명하는 '고전적인'구조를 이용해서 전략 패턴을 설명하고 구현한다. 고전적인 패턴에 익숙하다면, 함수를 이용해서 코드를 리팩토링하고 소스 코드를 엄청나게 줄일 수 있는 '함수지향 전략'으로 바로 넘어가도 좋다.

## 고전적인 전략
밑의 그림은 UML 클래스의 전략 패턴의 예를 보여준다.
![UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part6/ex6-1/UML_class_diagram.png)

**콘텍스트**
일부 계산을 서로 다른 알고리즘을 구현하는 교환 가능한 컴포넌트에 위임함으로써 서비스를 제공한다. 전자상거래 예제에서 콘텍스트는 Order로서, 여러 알고리즘 중 하나에 따라 프로모션 할인을 적용하도록 설정된다.

**전략**
여러 알고리즘을 구현하는 컴포넌트에 공통된 인터페이스. 전자상거래 예제에서는 이 역할을 Promotion이라는 추상 클래스가 담당한다.

**구체적인 전략**
전략의 구상 서브클래스 중 하나. 여기에서는 FidelityPromo, BulkItemPromo, LargeOrderPromo등 총 3개의 구체적인 전략이 구현되어 있다.

디자인 패턴에서는 전략 패턴을 다음과 같이 설명한다.
> **일련의 알고리즘을 정의하고 각각을 하나의 클래스 안에 넣어서 교체하기 쉽게 만든다. 전략을 이용하면 사용하는 클라이언트에 따라 알고리즘을 독립적으로 변경할 수 있다.**

전략 패턴의 예는 고객의 속성이나 주문한 상품에 따라 할인을 계산하는 전자상거래 영역에서 쉽게 볼 수 있다.

온라인 상점이 다음과 같은 할인 규칙을 갖고 있다고 가정하자.
* 충성도 포인트가 1,000점 이상인 고객은 전체 주문에 대해 5% 할인을 적용한다.
* 하나의 주문에서 20개 이상의 동일 상품을 구입하면 해당 상품에 대해 10% 할인을 적용한다.
* 서로 다른 상품을 10종류 이상 주문하면 전체 주문에 대해 7% 할인을 적용한다.

설명을 간단히 하기 위해 하나의 주문에는 하나의 할인 규칙만 적용된다고 가정하자.

밑의 예제는 위 그림의 설계를 코드로 구현한 것이다. 디자인 패턴에 설명된 대로 구체적인 전략은 콘텍스트 클래스의 클라이언트에 의해 선택된다. 이 예제에서는 주문 객체를 생성하기 전에 시스템이 할인 전략을 선택해서 Order 생성자에 전달한다. 전략의 선택은 패턴 범위를 벗어난다.

- [order_class예제](https://github.com/hyeonDD/fluent_python/blob/master/Part6/ex6-1/order_class.py)
    * 위 예제에서는 @abstractmethod 데커레이터를 사용할 수 있도록 Promotion을 추상 베이스 클래스로 구현했으므로, 전략 패턴을 더욱 명시적으로 보여준다.
    > 파이썬 3.4에서는 위예제처럼 abc.ABC 클래스를 상속해서 간단히 ABC(추상 베이스 클래스)를 선언할 수 있다. 파이썬3.0부터 3.3까지는 class Promotion(metaclass=ABCMeta):완 같이 class문에서 metaclass 키워드를 사용해야 한다.
<!-- 
- [order_class사용](https://github.com/hyeonDD/fluent_python/blob/master/Part6/ex6-1/order_class.py)
 -->
- [order_class사용](https://github.com/hyeonDD/fluent_python/blob/master/Part6/ex6-1/order_class_usage.py)
    1. 고객 두 명의 충성도 점수. joe는 0점, ann은 1,100점이다.
    2. 한 쇼핑 카트의 항목 종류가 3가지다.
    3. FidelityPromo 할인은 joe에게 아무런 할인도 해주지 않는다.
    4. ann은 충성도 점수가 1,000점이 넘으므로 5%를 할인받는다.
    5. banana_cart에는 banana 상품이 30개, apple 상품이 10개 들어 있다.
    6. BulkItemPromo 할인 덕분에 joe는 바나나에 대해 1.50달러를 할인받는다.
    7. long_order에는 각각 1.00달러인 10개의 서로 다른 상품이 있다.
    8. LargeOrderPormo 때문에 joe는 전체 주문에 대해 7%를 할인받는다.
    위 예제는 제대로 작동하지만, 파이썬에서 함수를 객체로 사용하면 더 적은 코드로 동일한 기능을 구현할 수 있다. 함수를 객체로 사용해서 구현하는 방법을 알아보자.

## 함수지향 전략
위 order_class.py 에서 각각의 구체적인 전략은 discount()라는 메서드 하나를 가진 클래스다. 게다가 전략 객체는 상태(객체 속성)을 가지고 있지 않다. 구체적인 전략 객체가 일반 함수로 보인다고 생각하면 제대로 본 것이다. 밑 [할인 전략을 함수로 구현한 Order 클래스]는 위[order_class예제]를 리팩토링한 것으로서, 구체적인 전략을 간단히 함수로 변경했고 Promotion 추상 클래스를 제거했다.

- [할인 전략을 함수로 구현한 Order 클래스](https://github.com/hyeonDD/fluent_python/blob/master/Part6/ex6-1/order_class_refactoring.py)
    1. 할인액을 계산하려면 self.promotion()함수를 호출하면 된다.
    2. 추상 클래스가 제거되었다.
    3. 각각의 구체적인 전략이 함수로 구현되었다.

- [할인 전략을 함수로 구현한 Order 클래스 사용예](https://github.com/hyeonDD/fluent_python/blob/master/Part6/ex6-1/order_class_refactoring_usage.py)
    1. order_class_usage.py 와 동일한 테스트 결과
    2. Order 객체에 할인 전략을 적용하려면 할인 함수를 인수로 전달하면 된다.
    3. 이곳과 다음 테스트에서 서로 다른 할인 함수를 사용한다.
    바로 위 예제에서는 Order 객체마다 할인 전략 객체를 만들 필요가 없다. 할인 전략 함수를 바로 사용할 수 있기 때문이다.

**디자인패턴**저자는 "전략 객체는 종종 훌륭한 플라이웨트가 되기도 한다"는 흥미로운 설명을 했으며, "플라이웨이트는 여러 콘텍스트에서 동시에 사용할 수 있는 공유 객체"라고 정의했다. 새로운 새로운 몬텍스트에서 동일 전략 객체를 반복해서 적용할 때는 새로 생성하는 비용을 줄이기 위해 플라이웨이트를 공유하는 것이 좋다. 우리 예제의 경우 Order 객체를 만들 때 기존 전략 객체가 있으면 재사용할 수 ㅇ있다. 따라서 전략 패턴의 단점인 '런타임 비용'을 극복하기위해 저자들은 또 다른 패턴인 플라이웨이트 패턴을 사용하도록 권고한다. 반면 소스 코드의 행 수와 유지보수 비용은 눈덩이처럼 불어난다.

구체적인 전략 객체가 내부 상태를 가지고 있어서 더욱 복잡한 경우에는 모든 전략 패턴과 플라이웨이트 패턴을 혼합해서 사용해야 한다. 그렇지만 구체적인 전략 객체가 내부 상태를 가지지 않고 단지 콘텍스트에서 오는 데이터를 처리하는 경우도 많다. 이런 경우에는 또 다른 추상 클래스에서 정의된 메서드를 하나만 구현하는 클래스를 만들기보다는 일반 함수를 만드는 것이 훨씬 좋다. 함수는 사용자 정의 클래스보다 훨씬 가볍고 파이썬이 모듈을 컴파일할 때 단 한번만 사용되므로 플라이웨이트가 필요하지 않다. 일반 함수도 '여러 콘텍스트에서 동시에 공유할 수 있는 공유 객체'임을 명심하자.

전략 패턴을 함수로 구현했으므로, 또 다른 문제가 생길 수 있다. 예를 들어 주어진 Order 객체에 대해 적용할 수 있는 가장 좋은 할인 전략을 선택하는 '메타 전략'을 만든다고 가정해보자.
다음 절에서는 코드를 더 많이 리팩토링하고 함수와 모듈을 객체로 활용하는 다양한 방법을 이용해서 최선의 전략을 찾아내는 방법을 알아본다.

## 최선의 전략 선택하기: 단순한 접근법
[할인 전략을 함수로 구현한 Order 클래스 사용예](https://github.com/hyeonDD/fluent_python/blob/master/Part6/ex6-1/order_class_refactoring_usage.py)의 테스트와 동일한 고객, 쇼핑카트가 주어졌을 때 아래와 같이 테스트 3개를 추가해보자.
```
print(Order(joe, long_order, best_promo))
print(Order(joe, banana_cart, best_promo))
print(Order(ann, cart, best_promo))
```
1. 고객 joe가 long_order 카트를 가지고 있으면 best_promo()는 larger_order_promo()를 선택한다.
2. 고객 joe가 바나나가 많이 들어있는 banana_cart를 가지고 있으면 best_promo()는 bulk_item_promo()로 가장 많이 할인받을 수 있다.
3. 고객 joe가 long_order단순히 cart를 가지고 있으면 best_promo()는 fidelity_promo()로 가장 많이 할인받을 수 있다.

밑의 소스코드 처럼 best_promo()는 간단히 구현할 수 있다.
```
promos = [fidelity_promo, bulk_item_promo, large_order_promo]

def best_promo(order):
    """최대로 할인받을 금액을 반환한다."""
    return max(promo(order) for promo in promos)
```
1. promos는 함수로 구현된 전략들의 리스트다.
2. best_promo는 다른 *_promo()함수들처럼 Order 객체를 인수로 받는다.
3. 제너레이터 표현식을 이용해서 promos에 있는 각 함수를 order에 적용하고, 최대 할인액을 계산한다.

위 방법은 간단하다. promos는 함수들의 리스트다. 일단 함수가 일급 객체라는 개념에 익숙해지면 함수를 담고 있는 데이터 구조체를 만든다는 생각이 자연스럽게 떠오른다.
위 방법은 가독성이 좋고 제대로 작동하지만, 일부 코드가 중복되어 있어 버그가 생길 여지가 있다. 새로운 할인 전략을 추가하려면 함수를 코딩하고 이 함수를 promos 리스트에 추가해야 한다. 아니면 새로운 할인 함수를 Order 객체에 인수로 전달해서 작동시킬 수 있지만, 이때 best_promo()는 새로운 할인 함수를 고려하지 않는다.

지금부터 이 문제를 해결하는 두 가지 방법을 알아보자.

## 모듈에서 전략 찾기
파이썬 모듈도 일급 객체로서, 모듈을 다루는 여러 함수가 표준라이브러리에서 제공된다. 파이썬 문서에서는 globlas() 내장 함수를 다음과 같이 설명하고 있다.

***
globals()
현재 전역 심벌 테이블을 나타내는 딕셔너리 객체를 반환한다. 이 딕셔너리는 언제나 현재 모듈에 대한 내용을 담고 있다(함수나 메서드 안에서 호출할 때, 함수를 호출한 모듈이 아니라 함수가 정의된 모듈을 나타낸다).
***

아래 소스코드는 globals()에 약간 꼼수를 부려 best_promo()가 자동으로 다른 *_promo()함수들을 찾아내게 한다.

```
promos = [globals()[name] for name in globals()
            if name.endswith('_promo')
            and name != 'best_promo']

def best_promo(order):
    """최대로 할인받을 금액을 반환한다"""

    return max(promo(order) for promo in promos)
```
1. globals() 함수가 반환한 딕셔너리에서 name을 반복한다.
2. _promo로 끝나는 name만 선택한다.
3. 무한 재귀 호출을 피하기 위해 best_promo 자신은 걸러낸다.
4. best_promo() 내부는 변경되지 않았다.
별도의 모듈을 만들고 best_promo()를 제외한 모든 프로모션 할인 함수를 그 모듈에 넣어서, 적용할 수 있는 모든 할인 함수를 모으는 방법도 있다.

아래에서는 promotions라는 별도 모듈에 내부 조사를 수행해서 만든 전략 함수 리스트를 사용하도록 변경했다. 아래는 inspect와 promotions를 임포트해야 작동한다.
inspect 모듈은 상위 수준의 내부 조사 함수를 제공한다

```
promos = [func for name, func in
                inspect.getmembers(promotions, inspect.isfunction)]

def best_promo(order):
    """최대로 할인받을 금액을 반환한다"""

    return max(promo(order) for promo in promos)
```
inspect.getmembers()함수는 조건식(불리언형 함수가 사용된다)으로 걸러낸 객체의 속성들을 반환한다. 여기서는 모듈 안에서 함수만 걸러내기 위해 inspect.isfunction()조건식을 사용한다.

위 소스코드는 할인 함수명에 상관없이 작동한다. 단지 주어진 주문에 대해 할인액을 계산하는 함수들만 promotions 모듈에 넣으면 된다. 물론 이것은 코드 안에서 암묵적으로 동의하는 가정 사항이다. 누군가 promotions 모듈 안에 다른 시그너처를 가진 함수를 추가하면, order에 적용하는 동안 best_promo()함수가 오류를 발생할 것이다.

객체의 인수를 조사함으로써 함수를 걸러내기 위해 더욱 엄격하게 테스트할 수 도있다. 위 소스코드는 완벽한 해결책을 제시하기 위한 것이 아니라, 모듈 내부 조사를 사용하는 방법에 **주안점**을 두고있다.

할인 함수를 동적으로 수집할 때, 간단한 데커레이터를 사용하면 더욱 명시적으로 처리할 수 있다. 이 전자상거래 전략의 또 다른 버전은 함수 데커레이터를 설명하는 7장에서 다시 설명한다.