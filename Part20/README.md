# 속성 디스크립터

디스크립터를 이용하면 여러 속성에 대한 동일한 접근 논리를 재사용할 수 있다. 예를 들어 장고와 SQL Alchemy의 ORM(객체 관계 매핑)에 있는 필드는 디스크립터로 구현되어 있어서, 데이터베이스 레코드의 필드에 들어 있는 데이터를 파이썬 객체 속성으로 상호 변환할 수 있게 해준다.

디스크립터는 __get__(), __set__(), __delete__() 메서드로 구성된 프로토콜을 구현하는 클래스다. property 클래스는 디스크립터 프로토콜을 완벽히 구현한다. 프로토콜과 마찬가지로 일부만 구현해도 된다. 사실 우리가 실제로 보는 대부분의 디스크립터는 __get__()과 __set__() 메서드만 구현하며, 이 메서드들 중 하나만 구현하는 디스크립터도 많다.

디스크립터는 파이썬의 독특한 특징으로서, 애플리케이션 수준뿐만 아니라 언어의 기반 구조에도 적용되어 있다. 프로퍼티 외에도 메서드 및 @classmethod와 @staticmethod 데커레이터가 디스크립터를 활용하는 파이썬 기능이다. 파이썬을 정복하려면 디스크립터를 알아야 한다. 이 장에서는 디스크립터를 집중적으로 다룬다.

# 요약

이 장은 19장에서 구현했던 LineItem 클래스로 시작해서 bulkfood_v3.py에서 프로퍼티를 디스크립터로 교체했다. 디스크립터는 일종의 클래스로서, 디스크립터 객체는 관리 대상 클래스의 속성으로 사용된다. 이런 메커니즘을 설명하기 위해 관리 대상 객체와 저장소 속성 등의 특별한 용어가 필요했다.

20.1.2절 'LineItem 버전 #4: 자동 저장소 속성명'에서는 storage_name을 명시적으로 지정하지 않고 Quantity 디스크립터를 선언할 수 있게 변경했다. 저장소 속성명은 디스크립터 객체를 할당하는 문의 왼쪽에 있는 속성명과 일치해야 하므로, 중복 문제 때문에 오류가 발생하기 쉽기 때문이다. 이 문제를 해결하기 위해 디스크립터 클래스명과 카운터를 클래스 수준에서 조합해서 '_Quantity#1'과 같은 고유한 storage_name을 자동으로 생성했다.

그러고 나서 함수형 프로그래밍 관용구를 사용하는 프로퍼티 팩토리와 디스크립터 클래스의 코드 길이, 장단점을 비교했다. 프로퍼티 팩토리는 경우에 따라 더욱 간단하게 구현할 수 있고 완벽하게 작동하지만, 디스크립터는 융통성이 높은 표준작언 방법이다. 디스크립터 클래스의 가장 큰 장점은 20.1.3절 'LineItem 버전 #5: 새로운 디스크립터형'에서 공통된 기능을 공유하는 특화된 디스크립터를 생성할 때 명확히 드러났다.

다음으로 __set__() 메서드의 제공 여부에 따라 달라지는 디스크립터의 작동에 대해 살펴보면서 오버라이딩 디스크립터와 논오버라이딩 디스크립터의 커다란 차이점을 설명했다. 상세한 테스트를 통해 디스크립터가 제어권을 가지는 경우와 디스크립터 객체를 가리거나, 우회하거나, 덮어쓰는 경우에 대해 알아보았다.

그리고 일종의 논오버라이딩 디스크립터인 '메서드'에 대해 살펴보았다. 콘솔 세션에서 디스크립터 프로토콜을 활용해서, 클래스에 연결된 함수가 객체를 통해 접근할 때 어떻게 메서드가 되는지 알아보았다.

20.4절 '디스크립터 사용에 대한 조언'에서는 디스크립터 삭제와 문서화가 어떻게 작동하는지 간략히 살펴보았다.

이 장에서는 클래스 메타프로그래밍을 통해서만 해결할 수 있는 문제가 몇 가지 나왔다. 다음 장에서는 클래스 메타프로그래밍에 대해 살펴볼 것이다.