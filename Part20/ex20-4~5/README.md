<!-- 
- [](https://github.com/hyeonDD/fluent_python/blob/master/Part20/ex20-4~5/UML_class_diagram.png)
 -->
# 디스크립터 사용에 대한 조언

지금까지 설명한 디스크립터의 특징을 정리하자. 디스크립터를 사용할 때 고려해야 할 사항은 다음과 같다.

---

**코드를 간결하게 작성하기 위해 프로퍼티를 사용하라**
property() 내장 함수는 세터 메서드를 정의하지 않는 경우에도 __set__()과 __get__() 메서드를 모두 구현하는 오버라이딩 디스크립터를 생성한다. 프로퍼티의 기본 __set__() 메서드는 'AttrivuteError: can't set attribute' 예외를 발생시키므로, 프로퍼티는 읽기 전용 속성을 만들기 위한 가장 간단한 방법이다(디스크립터는 다음 항목에서 설명하는 문제가 있다).

**읽기 전용 디스크립터는 __set__()을 구현해야 한다**
디스크리버 클래스를 이용해서 읽기 전용 속성을 구현하려면 __get__()과 _-set__() 메서드를 모두 구현해야 한다. 그렇지 않으면 객체가 동일한 이름의 속성을 가질 때 디스크립터가 가려진다. 읽기 전용 속성의 __set__() 메서드는 적절한 메시지를 담아서 AttributeError를 발생시켜야 한다.

**검증 디스크립터는 __set__()만 사용할 수 있다**
검증하기 위해 만들어진 디스크립터에서는 __set__() 메서드만 이용해서 값의 정당성을 검증하고, 값이 정당한 경우 디스크립터 객체명과 동일한 이름의 속성을 __dict__에 직접 설정해야 한다. 이렇게 하면 디스크립터 객체명과 동일한 이름의 속성을 읽을 때 __get__()을 거치지 않으므로 객체의 속성을 더 빨리 읽을 수 있다. [bulkfood_v3.py](https://github.com/hyeonDD/fluent_python/blob/master/Part20/ex20-1/bulkfood_v3.py)를 참조하라.

**캐시는 __get__()에서만 효율적으로 구현할 수 있다**
__get__() 메서드만 구현하면 논오버라이딩 디스크립터가 된다. 논오버라이딩 디스크립터는 값비싼 연산을 수행하고 객체에 있는 동일명의 속성에 결과를 저장해서 캐시할 때 유용하게 사용할 수 있다. 동일명의 객체 속성이 디스크립터를 가리므로, 이후에 이 속성을 읽을 때는 디스크립터의 __get__() 메서드를 더 이상 사용하지 않고 __dict__에서 바로 가져온다.

**특별 메서드 이외의 메서드는 객체 속성에 의해 가려질 수 있다**
함수와 메서드는 __get__()만 구현하므로 동일한 이름의 객체 속성에 저장하는 연산은 간섭하지않는다. 따라서 my_obj.the_method = 7과 같이 할당하면, 클래스와 다른 객체에는 영향을 미치지 않고 이후에 my_object의 the_method를 읽을 때 7을 반환한다. 그러나 이런 방식이 특별 메서드에 대해서는 작동하지 않는다. 파이썬 인터프리터는 클래스 자에체 있는 특별 메서드를 먼저 검색한다. 예를 들어 repr(x)는 x.__class__.__repr__(x)를 호출하므로 x에 정의된 __repr__ 속성은 repr(x)에 영향을 미치지 않는다. 이와 같은 이유로 객체에 __getattr__이라는 이름의 속성이 존재하더라도 속성에 접근하는 알고리즘에 전혀 영향을 끼치지 못한다.

---

특별 메서드 이외의 메서드가 객체에 의해 쉽게 오버라이드될 수 있다는 사실 때문에 불안정하고 에러가 발생하기 쉬울 것 같지만, 15년 넘게 파이썬으로 코딩하면서 필자는 이런 문제를 겪은적은 없다. 오히려 이 장 앞에서 구현했던 예제처럼 직접 통제하지 않는 데이터를 가져와서 속성명으로 사용하면서 동적 속성을 많이 생성하는 경우, 이런 문제를 예상하고 코드에 문제를 야기할 수 있는 동적 속성명을 거러 내거라 피해가는 방법을 구현해야 한다.
> 예제19-6의 FrozenJOSN 클래스는 특별 메서드와 build()클래스 메서드만 사용하므로 객체 속성이 메서드를 가리는 문제가 없다. 19-6의 FrozenJSON.build()에서 했던 것처럼 클래스를 통해 접근하는 한 클래스 메서드는 안전하다(19-7에서는 build()메서드를 __new__() 메서드로 대체했다.). 19-9와 19-11의 Record 클래스 및 이 클래스의 서브클래스도 특별 메서드, 클래스 메서드, 정적 메서드, 프로퍼티만 사용하므로 안전하다. 프로퍼티는 데이터 디스크립터이므로, 객체 속성이 가릴 수 없다.

이 장을 마치기 전에, 프로퍼티에서는 설명했지만 디스크립터에서는 설명하지 않았던 두 가지 특징, 즉 디스크립터의 문서화 및 관리 대상 속성의 삭제를 처리하는 방법에 대해 알아보자.

# 디스크립터의 문서화 문자열과 관리 대상 속성의 삭제

디스크립터 클래스의 문서화 문자열은 관리 대상 클래스에 있는 모든 디스크립터 객체를 문서화하기 위해 사용된다. 아래그림은 [model_v5.py](https://github.com/hyeonDD/fluent_python/blob/master/Part20/ex20-1/model_v5.py)와 [bulkfood_v5.py](https://github.com/hyeonDD/fluent_python/blob/master/Part20/ex20-1/bulkfood_v5.py)의 Quantity와 NonBlank 디스크립터를 가진 LineItem 클래스에 대한 도움말 화면이다.

이 도움말은 다소 만족스럽지 않다. 예를 들어 LineItem의 경우, weight는 킬로그램 단위로 입력해야 한다는 정보가 있으면 좋을 것이다. 각각의 프로퍼티는 특정 관리 대상 속성을 처리하므로, 프로퍼티에 이러한 도움말을 추라가하는 것은 간단할 것이다. 그러나 디스크립터의 경우, 동일한 Quantity 클래스가 weight에도 사용되고 price에도 사용된다.

![help_LineItem.png](https://github.com/hyeonDD/fluent_python/blob/master/Part20/ex20-4~5/help_LineItem.png)

프로퍼티에 대해서는 설명했지만 디스크립터와 관련해서는 설명하지 않았던 두 번째 내용은 관리 대상 속성의 삭제를 처리하는 것이다. 디스크립터 클래스에 일반적으로 구현하는 __get__()및 __set__() 메서드 외에 __delte__() 메서드를 구현하면 관리 대상 속성의 삭제를 처리할 수 있다. 우스꽝스러운 디스크립터 클래스에 __delete__() 메서드를 구현하는 것은 시간 있는 독자들에게 연습문제로 남겨둔다.
