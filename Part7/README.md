# 함수 데커레이터와 클로저
함수 데커레이터는 소스 코드에 있는 함수를 '표시'해서 함수의 작동을 개선할 수 있게 해준다. 강력한 기능이지만, 데커레이터를 자유자재로 사용하려면 먼저 클로저를 알아야 한다.

파이썬 3.0에 추가된 nonlocal은 최근에 추가된 예약 키워드 중 하나다. 클래스 중심의 엄격한 객체지향 방식을 고수한다면 이 기능을 사용하지 않고도 파이썬 프로그래머로서의 살멩 아무런 지장을 받지 않을 수 있다. 그러나 자기만의 데커레이터를 구현하고자 한다면 클로저를 속속들이 이해해야 하며, 그로거 나면 nonlocal이 필요해진다.

데커레이터에서 사용하는 것 외에도, 클로저는 콜백을 이용한 효율적인 비동기 프로그래밍과 필요에 따라 함수형 스타일로 코딩하는 데에도 필수적이다.

이 장의 궁극적인 목표는 아주 단순한 등록 데커레이터에서부터 복잡한 매개변수화된 데커레이터에 이르기까지 함수 데커레이터가 정확히 어떻게 작동하는지 설명하는 것이다. 그렇지만 목표에 도달하기 전에 다음과 같은 내용을 먼저 살표봐야 한다.
* 파이썬이 데커레이터 구문을 평가하는 방식
* 변수가 지역 변수인지 파이썬이 판단하는 방식
* 클로저의 존재 이유와 작동 방식
* nonlocal로 해결할 수 있는 문제
이런 기반을 갖추고 나면 다음과 같이 데커레이터 주제를 심도 있게 다룰 수 있다.
* 잘 작동하는 데커레이터 구현하기
* 표준 라이브러리에서 제공하는 재미있는 데커레이터들
* 매개변수화된 데커레이터 구현하기
먼저 데커레이터에 대한 아주 기초적인 내용부터 살펴보고, 위에서 나열한 주제들을 살펴보자.

# 요약
이 장에서는 많은 기반을 닦았으며, 까다로운 주제를 가능한 부드럽게 설명하려 노력했다, 결국 우리는 메타프로그래밍 영역에 들어섰다.

먼저 내부 함수를 가지지 않는 간단한 @register 데커레이터로 시작해서 두 단계의 내포된 함수를 가진 매개변화된 @clock() 데커레이터까지 살펴봤다.

등록 데커레이터는 본직적으로 간단한 메커니즘이지만 고급 파이썬 프레임워크에서 실제 사용되고 있다. 우리는 6장에서 구현한 예제를 리팩토링해서 전략 디자인 패턴을 개선하기 위해 등록 개념을 적용했다. 매개변수화된 데커레이터는 거의 항상 두단계의 내포된 함수를 가지고 있으며, 더 고급 지원을 지원하는 데커레이터를 구현하기 위해 @functools.wraps를 사용하는 경우 세 단계 이상 내포되기도 한다.

그리고 표준 라이브러리의 functools 모듈에서 제공하는 @lru_cache()와 @singledispatch등 두 개의 멋진 함수 데커레이터를 살펴보았다.

데커레이터가 실제 작동하는 방식을 이해하려면 **임포트 타임**과 **런타임**의 차이를 알아야 하며, 변수 범위, 클로저, 새로 소개된 nonlocal 선언에 대해서도 자세히 알아야 한다. 클로저와 nonlocal을 완전히 이해하면 데커레이터를 만들 수 있을 뿐만 아니라, GUI방식의 이벤트 주도 프로그램이나 콜백을 이용한 비동기 입출력을 구현할 때도 큰 도움이 된다.