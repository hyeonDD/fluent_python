<!-- 
[UML클래스전략패턴](https://github.com/hyeonDD/fluent_python/blob/master/Part9/ex9-1/UML_class_diagram.png)
 -->
# __slots__ 클래스 속성으로 공간 절약하기

기본적으로 파이썬은 객체 속성을 각 객체 안의 __dict__라는 딕셔너리형 속성에 저장한다.
3.9.3절 'dict 작동 방식에 의한 영향'에서 설명한 것처럼, 딕셔너리는 빠른 접근 속도를 제공하기 위해 내부에 해시 테이블을 유지하므로 메모리 사용량 부담이 상당히 크다. 만약 속성이 몇개 없는 수백만 개의 객체를 다룬다면,__slots__클래스 속성을 이용해서 메모리 사용량을 엄청나게 줄일 수 있다. __slots__속성은 파이썬 인터프리터가 객체 속성을 딕셔너리 대신 튜플에 저장하게 만든다.
> 슈퍼클래스에서 상속받은 __slots__ 속성은 서브클래스에 영향을 미치지 않는다. 파이썬은 각 클래스에서 개별적으로 정의된 __slots__속성만 고려한다.
__slots__를 정의하려면, 이 이름의 클래스 속성을 생성하고 여기에 객체 속성 식별자들을 담은 문자열의 반복형을 할당한다. 불변형인 튜플을 사용하면 __slots__ 정의를 변경할 수 없음을 알려주므로, 필자는 __slots__를 정의할 때 튜플을 즐겨 사용한다. 아래 예제를 보자.

- [slots만 추가한 Vector2d](https://github.com/hyeonDD/fluent_python/blob/master/Part9/ex9-8/vector2d_v3_slots.py)

__slots__를 클래스에 정의함으로써 '이 속성들이 이 클래스가 객체가 가지는 속성'임을 인터프리터에 알려준다. 그러면 파이썬 인터프리터는 이 속성들을 각 객체의 튜플형 구조체에 저장함으로써 __dict__속성을 각 객체마다 유지하는 부담을 덜어낸다. 한꺼번에 수백만 개의 객체를 사용한다면 이 방식은 메모리 사용량을 엄청나게 줄여준다.
> 수백만 개의 숫자 데이터를 처리하는 경우에는 NumPy를 사용하는 것이 좋다.(2.9.3절 'NumPy와 SciPy'참조). Numpy는 메모리를 효율적으로 사용할 뿐만 아니라 숫자 처리에 상당히 최적화된 함수들을 가지고 있으며, 그중 배열 전체를 한꺼번에 처리하는 함수도 많이 있다. 여기에서 구현하고 있는 Vector2d 클래스는 특별 메서드를 설명하기 위한 기반을 제공하기 위한 것일뿐이며, 실제 수학적 연산을 수행하기 위한 것은 아니다. 이 책에서는 foo나 bar처럼 모호한 이름의 예제는 사용하지 않으려고 노력했다.

아래 예제는 지능형 리스트를 이용해서 Vector2d 객체 1천만 개를 가진 리스트를 만드는 스크립트를 두번 실행한다. mem_test.py 스크립트는 Vector2d 클래스를 가진 모듈의 이름을 명령행 인수로 받는다. 첫 번째 실행할 때는 아래의 vector2d_v3.Vector2d 클래스를 사용하고, 두 번째 실행할 때는 이 클래스의 __slots__버전인 vector2d_v3_slots.Vector2d를 사용한다.

- [메모리 사용량 보기](https://github.com/hyeonDD/fluent_python/blob/master/Part9/ex9-8/vector2d_v3_slots.py)
* __dict__을 사용한 Vector2d는 1.5GB 를 사용했다.
* __slots__를 사용한 Vector2d는 655MB를 사용했고, __slots__버전이 좀더 빨랐다.
> 클래스 안에 __slots__를 명시하는 경우, 객체는 __slots__에 명시되지 않은 속성을 가질수 없게 된다. 이는 __slots__가 존재하는 이유는 아니며, 실제로는 부작용이다. 그러나 단지 여러분이 만든 클래스의 사용자가 객체에 새로운 속성을 추가할 수 없게 하기 위해 __slots__를 사용하는 것은 적절치 않다고 생각한다. __slots__는 최적화를 위해 사용하는 것이지, 프로그래머를 억압하기 위한 것은 아니다.

그러나 '애써 절약한 메모리를 낭비할' 수도 있따. '__dict__'문자열을 __slots__리스트에 추가하면 __slots__에서 지정한 속성들을 각 객체의 튜플에 저장하지만, 동적으로 속성을 생성할 수도 있게 해준다. 이때 동적으로 생성한 속성은 __dict__에 저장된다. 물론 __dict__를 __slots__안에 넣으면 각 객체의 정적 및 동적 속성의 수와 사용법에 따라 달라지기는 하지만 __slots__를 사용하는 의미를 상실하게 된다. 부주의한 최적화는 성급한 최적화보다 훨씬 더 나쁘다.

그리고 각 객체마다 유지하고 싶은 또 다른 특별 속성이 있다. 객체가 약한 참조를 지원하려면 __weakref__ 속성이 필요하다(8.6절 '약한 참조'). 이 속성은 사용자 정의 클래스에 기본적으로 존재한다. 그러나 클래스가 __slots__를 정의하고 이 클래스의 객체를 약한 참조의 대상이 되게 하려면 __weakref__를 __slots__ 리스트에 추가해야 한다.

지금까지 배운 것을 정리해보면, __slots__를 사용할 때는 주의할 점이 있으며, 단지 클래스의 사용자가 할당할 수 있는 속성을 제한하기 위해 사용해서는 안 된다. __sltos__는 고정된 스키마의 아주 큰 데이터베이스와 같은 테이블 형태의 데이터를 사용할 때 유용하다. 그러나 이런 형태의 데이터를 자주 처리해야 한다면 NumPy (http://www.numpy.org) 나 pandas 데이터 분석 라이브러리 (http://pandas.pydata.org) 를 알아보는 것이 좋다. pandas 라이브러리는 비수치형 데이터를 처리할 수 있으며, 여러 테이블 형태의 데이터 포맷을 임포트 및 익스포트할 수 있다.

## __slots__를 사용할 때 주의할 점
__slots__는 적절히 사용하면 메모리 사용량을 엄청나게 줄일 수 있지만, 다음과 같이 주의할점이 있다.
* 인터프리터는 상속된 __slots__ 속성을 무시하므로 각 클래스마다 __slots__속성을 다시 정의해야 한다.
* __dict__를 __slots__에 추가하지 않는 한 객체는 __slots__에 나열된 속성만 가질 수 있다(그러나__dict__를 __slots__에 추가하면 메모리 절감 효과가 반감될 수 있다.)
* __weakref__를 __slots__에 추가하지 않으면 객체가 약한 참조의 대상이 될 수 없다.

프로그램이 수백만 개의 객체를 다루는 경우가 아니라면, 굳이 동적 속성을 받아들이지 않고 약한 참조를 지원하지 않는 까다로운 클래스를 만들 필요가 없다. 다른 최적화 작업과 마찬가지로 필요성이 정당화되고 신중히 프로파일링해서 효과가 입증된 경우에만 __slots__를 사용해야 한다.




