# 해시 가능한 Vector2d
지금까지 정의한 Vector2d는 해시할 수 없다. 그러므로 집합안의 항목으로 사용할 수 없다.

```
v2 = Vector2d(3, 4)
hash(v1)
Traceback (most recent call last):
 
 ...
TypeError: unhashable type: 'VVector2d'
set([v1])
Traceback (most recent call last):

 ...
TypeError: unhashable type: 'Vector2d'
```
Vector2d를 해시 가능하게 만드려면 __has__() 메서드를 구현해야 한다 (__eq__() 메서드도 필요하지만, 이 메서드는 이미 구현했다). 그리고 3.1절의 **해시 가능하다는 말의 의미는?** 글상자에서 서령한 것처럼 Vector2d 객체를 불변형으로 만들어야 한다.

현재 구현된 Vector2d로는 v1.x = 7과 같이 속성을 변경하는 코드가 아무런 문제 없이 실행된다. Vector2d를 불변형으로 만들면 다음과 같이 실행된다.
```
v1.x v1.y
#(3.0 4.0)
v1.x = 7
Traceback (most recent call last):

 ...
AttributeError: can't set attribute
```

먼저 [예제 9-7]에서 보는 것처럼 x와 y 요소를 읽기 전용 속성으로 만들자.

- [불변형 Vector 예제](https://github.com/hyeonDD/fluent_python/blob/master/Part9/ex9-6~7/vector2d_v3.py)
1. 정확히 두 개의 언더바로 시작해서(뒷부분의 언더바는 없거나 하나만 사용한다) 속성을 비공개로 만든다.
2. @property 데커레이터는 프로퍼티의 게터 메서드를 나타낸다.
3. 자신이 노출시키는 공개 속성명을 따라 게터 메서드의 이름을 저장한다.
4. 단지 self.__x를 반환한다.
5. y 프로퍼티도 동일하게 정의한다.
6. x와 y의 속성을 읽기만 하는 다른 메서드들은 비공개 속성 대신 self.x와 self.y를 통해 공개 프로퍼티를 읽으므로 변경하지 않아도 된다. 따라서 클래스의 나머지 메서드 코드는 생략한다.
> Vector2d.x와 Vector2d.y는 읽기 전용 프로퍼티를 보여준다. 읽고 쓸 수 있는 프로퍼티는 @property 데커레이터를 다루는 19장에서 자세히 설명한다.

Vector2d를 불변형으로 만들었으니, 이제 __has__() 메서드를 구현할 차례다. __has__()메서드는 int 형을 반환해야 한다. 그리고 동일하다고 판단되는 객체는 동일한 해시값을 가져야 하므로 __eq__() 메서드가 사용하는 객체의 속성을 이용해서 해시를 계산하는 것이 이상적이다. __has__() 특별 메서드 문서 (https:/docs.python.org/3reference/datamodel.hmtl) 에서는 요소의 해시에 비트 단위 XOR(베타적 논리합) 연산자(^)를 사용하는 것을 권장하므로, 여기서도 그 방법을 따른다. 우리가 구현한 Vector2d.__hash__()메서드는 아래 예제에서 보는 것처럼 아주 간단하다.
```
# Vector2d 클래스 내부

def __has__(self):
    return hash(self.x) ^ hash(self.y)
```

__hash__() 메서드를 추가해서 Vector2d를 해시 가능한 클래스로 만들었으므로, 다음과 같이 Vector2d를 사용할 수 있다.

```
v1 = Vector2d(3, 4)
v2 = Vector2d(3.1, 4.2)
hash(v1), hash(v2)
set([v1, v2])
```
> 해시 가능형을 만들기 위해 반드시 프로퍼티를 구현하거나 객체 속성을 보호할 필요는 없다. 단지 __hash__()와 __eq__() 메서드를 제대로 구현하면 된다. 그러나 객체의 해시값이 변하면 안 되므로 읽기 전용 프로퍼티를 설명하기에 좋은 기회이긴 하다.
적절한 스칼라 값을 가진 자료형을 만들 때는 경우에 따라 자료형을 강제 변환하기 위해 사용되는 int()와 float()가 호출하는 __int__()와 __float__() 메서드를 구현하는 것도 좋다. 내장된 complex() 생성자를 지원하기 위한 __complex__() 메서드도 있다. Vector2d도 __complex__() 메서드를 구현해야 하지만, 이것은 연습문제로 남겨둔다.

지금까지 Vector2d 클래스를 개선했지만, 추가된 코드 부분만 봤다. 아래 예제는 지금까지 수정한 내용을 전부 반영하고, 클래스를 개발하기 위해 사용한 doctest를 포함해서 vector2d_v3.py 코드를 모두 보여준다.

- [vector2d_v3.py 전체코드](https://github.com/hyeonDD/fluent_python/blob/master/Part9/ex9-6~7/vector2d_v3_final.py)
이 절과 바로 앞 절에서 수행한 것을 정리해보면, 우리는 몇 가지 특별 메서드를 구현해서 기능을 완전히 갖춘 객체를 가지게 되었다. 물론 애플리케이션에서 사용할 필요가 없는 메서드를 구현하는 것은 좋은 생각이 아니다. 사용자는 객체가 '파이썬스러운지'아닌지 신경 쓰지 않는다.

위 예제에서 구현한 Vector2d는 객체 표현에 관련된 특별 메서드들을 장황하게 보여주는 엄격한 예지만, 모든 사용자 정의 클래스가 따라야 하는 틀은 아니다.

다음 절에서는 Vector2d를 잠시 멈추고, self._x처럼 이중 언더바로 시작하는 파이썬 비공개 속성 매커니즘의 설계와 단점에 대해 알아보자.

# 파이썬에서의 비공개 속성과 보호된 속성
파이썬에는 private 수정자가 있는 자바와 달리 비공개 변수를 생성할 수 있는 방법은 없지만, 서브클래스에서 **비공개** 성격의 속성을 실수로 변경하지 못하게 하는 간단한 매커니즘은 있다.

이런 시나리오를 생각해보자. 클래스 외부에 노출시키지 않고 내부적으로 개의 상태를 나타내는 mood 객체 속성을 사용하는 Dog라는 클래스가 있다. 우리는 Dog를 상속해서 Beagle이라는 클래스를 정의해야 한다. 이때 Dog에 mood라는 속성이 있는지 모르고 Beagle에서 mood라는 속성을 정의하는 경우 이름 충돌을 일으키게 된다. 그러면 Dog에서 상속된 메서드가 사용하는 mood속성값을 엉뚱하게 변경하게 된다. 이런 상황은 디버깅하기 힘들다.

이런 상황을 예방하기 위해 속성명을 __mood처럼 두 개의 언더바로 시작하고 언더바 없이 또는 하나의 언더바로 끝나도록 정의하면, 파이썬은 언더바와 클래스명을 변수명 앞에 붙여 객체의 __dict__에 저장한다. 따라서 Dog 클래스의 경우 __mod는 _Dog__mood가 되고 Beagle 클래스의 경우 _Beagle__mood가 된다. 이러한 파이썬의 언어 기능을 **이름 장식**이라고 한다.

```
v1 = Vector2d(3, 4)
v1.__dcit__
#{'_Vector2d__y': 4.0, '_Vector2d__x': 3.0}
v1._Vector2d__x
3.0
```
이름 장식은 안전을 제공하지만, 보안 기능은 아니다. 실수로 접근하는 것을 막도록 설계되어 있지만 고의적인 악용을 막지는 못한다.

비공개 이름이 어떻게 만들어지는지 아는 사람은 위 예제 코드의 마지막 명령에서 보여주는 것처럼 비공개 속성을 직접 읽을 수 있다. 사실 이 기법은 디버깅과 직렬화에 유용하게 사용된다. 그리고 v1._Vector__x = 7과 같이 작성하면 Vector2d의 비공개 요소에 직접 값을 할당할 수도 있다. 그러나 실제 운용하는 코드에서 이렇게 조작해서 문제가 생기더라도 불만을 제기할 곳이 없다.

모든 파이썬 개발자가 이름 장식 기능과 self.__x처럼 한쪽으로 길우어진 이름을 좋아하는 것은 아니다. 이런 구문을 피하고 self._x처럼 언더바 하나를 붙여 속성을 '보호'하는 것을 좋아하는 개발자도 있다. 기계적인 이중 언더바 장식을 비판하는 사람은 속성 충돌은 명명관례를 통해 해결해야 한다고 제안한다. 다음은 이 장 시작부분에서 인용한 이안 비킹의 말을 전부 옮긴 것이다.

> **절대로 결코 앞에 언더바 두 개를 사용하지 말라. 이것은 짜증스러울 정도로 개인적인 이름이다. 이름 충돌이 문제가 된다면, 대신 _MyThing_blahblah처럼 명시적으로 이름을 장식하는 것이 좋다. 이 방식도 본질적으로는 이중 언더바를 붙이는 방식과 다르지 않지만, 이중 언더바는 의도가 모호한 반면 명시적으로 이름을 장식하는 방식은 의도를 명확히 보여준다.**

속성명 앞에 언더바 하나를 붙이더라도 파이썬 인터프리터가 별도로 특별히 처리하는 것은 없지만, 클래스 외부에서 그런 속성에 접근하지 않는 것은 파이썬 프로그래머 사이에 일종의 금기처럼 자리 잡혀 있다. 언더바 하나를 앞에 붙여서 표시한 객체의 프라이버시를 존중하는 것은 모든 글자를 대문자로 사용하는 상수를 존중하는 것처럼 간단한 일이다.

파이썬 문서 일부에서는 단일 언더바로 시작하는 속성을 '보호된'속성이라고 부르기도 한다. self._x 형태의 속성을 '보호'하는 관례는 대부분의 개발자가 보편적으로 따르고 있지만, 이런 속성을 '보호된'속성이라고 부르는 일은 거의 없다. 심지어 이런 속성을 '비공개'속성이라고 부르는 개발자도 있다.

정리하면, Vector2d 요소는 '비공개'속성이며, Vector2d 객체는 '불변형'이다. 파이썬에는 비공개 속성과 불변 속성을 정의하는 진정한 방법이 없기 때문에, 주의를 요한다는 의미에서 따옴표로 표시했다.

이제 다시 Vector2d 클래스로 돌아가자. 다음 절에서는 객체의 내부 저장소에 영향을 미치는 특별 속성(메서드가 아니다)인 __slots__에 대해 설명한다. __slots__는 클래스의 외부 인터페이스에는 거의 영향을 미치지 않지만, 메모리 사용량에는 엄청난 영향을 미친다.